Keeping Passwsords Safe in 2017
By
Emil Bay

       [no audio] 
      >> I have worked at an advertisement agency and I worked at a high performance computing lab.  And most recently I've worked at a newspaper as a data journalist.  But today we're talking about passwords.  Just to get everyone on the same page, I'm sure you know what passwords are.  But technically if you know a password, it's something to identify yourself.
      If you know a password, it's pretty much equivalent to your identity online.  When you do on a Website, it's not like you're showing your passport or anything like that.  You have a password.  And the state of the world, everyone has passwords.  My grandmother has a password as well. if you can steal someone's password, it has a lot of implications.  And as a matter of fact, most people only have one password.
      So your password is your identity.  If someone steals it, they have your whole identity.  They can log in as you everyone on the Internet kind of thing.  So what can we do about this?  As I see it, three things we can do.  Eradicate all security holes which is a pretty noble task.  I think that's what the world strives to do, right?  But it's probably not going to work out in the shortterm.  Another thing and another thing we can do is have unique passwords everywhere.  I don't know about you, but I keep a password safe with a unique password for every Website.  You can't trust Websites, I'm going to show you.  But as software provider, you can use safer password storage.  That's what we're going to talk about today.
      So here's a question for you.  What do all these companies have in common?  They were visited by this guy.  Now, in the Lego world, every Lego man looks alike.  This is not me.  This is some other Lego guy, right?  So in this talk the way we're going to go about things is we're going to build safe password storage from the ground up.   The first and easiest way to store passwords is plain text.  And I'm sure plain text to a lot of you guys it already has ate alarm bells ringing, right?  So let's look at some code here.  Look at the examples after the talk, this is the model I've used throughout all the examples.
      So we have a database of some kind.  In this case, it's just a map that sits over in another file.  Then we have a register function and a login function.  Often these two functions are not symmetrical.  You store the function, and on the other you have to verify that the password was the same as was provided when you signed up.  And we return true or false depending on whether the password is valid.  And you can see down here at the bottom I have a register function where I register my user name and then because we are in Germany, I have chosen the password to be handschuh, which is glove.  But literally translated means "Hand shoe."  I don't know.
      And we should attempt to log in and see true on the console.  And afterwards I'm going to use the wrong password which means funny  but it can mean funny guy kind of thing.  Let's see that the model for the talk works.  We get a true and a false, which we're supposed to.  Great.
      Now, as I said before, plain text doesn't really work out.  But that doesn't stop these guys from actually implementing plain text storage for passwords.  I don't know if you have heard about this famous Sony hack in 2011 where they stole all of the PlayStation network  they were stored in plain text.  Bell, a Canadian television provider stored all the passwords in plain text.  Comcast.  Yeah.  So the problem, plain text.  Just a problem enough itself.  What can we do about it?  We can try to obscure the passwords.  We're not going to encrypt the passwords.  That's not what we're going.  We're going to look at another vendor later that did encrypt their passwords but had no idea what they were doing.
      What are we going to use?  It's something called a hash function.  You probably know what a hash function is or heard the word hash function.  And hash functions powers the small, random numbers you get from your Git commits.  But they have other properties that are variable.  One is deterministic.  So deterministic means that the output is solely dependent on the input.  There is nothing in there, what's the alignment of the planets, what's the random number, take a rabbit out of a hat.  So deterministic, very important.
      Number two, it's preimage resistant.  That's a nice way of saying that it's one way.  It means that you can't take the output and figure out what the input was.  You can only take the input and get the output.  Never the other way around kind of thing.  And it has another property that sounds kind of similar, the preimage assistant.  And that means if you have a hash function, or you have the hash, you know what the input to the hash function was, you can find another input that gives the same hash.
      So that means you can find another password that gives the same hash.  Meaning that you would be able to find like a completely different password and try to crack the hashing function.  And last thing is collision resistance.  And that's kind of an involuntary collision.  Meaning by some accident two passwords map to the same hash, which is this as well.  So these are the properties the hash function has to obey.  And we're not going to build a hash function.  There are hash functions out there.
      I spent like three years being able to write this notation here.  So  yeah.  Waste of time.  So I will save you.  But this looks fancy, right?  So another nice thing about hash functions  hash functions have heaps and heaps of applications.  We are going to use them for passwords.  But the most amazing property about hash functions means that you can take an extremely long stream of bits and you can hash it down to something that's finite.  So it has like the bits in there.  It's amazing.  If you study hash functions, it will boggle your mind.
      So was there the demo?  No, that's at the end.  Here's hash functions.  You have heard of some of them.  MD5 was the first hash functions I learned about when I was building a system in PHP.  I was born in 1993, MD5 was breaking in 1996.  I was still wearing a diaper when it was broken.  You probably heard about the recent shatter attack.  This is broken too.  It had a nice run, but, yeah, it's gone now.
      Then we have a couple of other hash functions.  These are in green.  These are cryptographically secure hash functions, but they are fast, and that's something we don't want.  I'll show in a minute.  And you might have a hard time seeing this.  But I'll read, B script, S script, they are hash functions that you can use to store passwords.  Not what I recommend, but you can do that.  And then I have nothing is say about this one later.  I have a little demo.  Just open it up here.
      So because everyone knows MD5, and to make it clear that this is not the way you should do it, I used it as a hash function up here.  If you run this, you can see that it  note.  It gives the same output as before.  Pretty simple now instead of doing a strict equality to the string, we have to hash the password again and compare the two hashes.
      And you can see here, I also tried to use some German words.  Schildkrote, turtle and belina.  Yeah.  We get what we expect.  This is the boiled down version of how you would do a hash in note with core script.  The output of a hash function is often called a digest because you're like digesting something big into something small.  These are the offenders.  I don't know if you know these guys.  But in 2015  and I said this was broken when I was wearing a diaper.  In 2015, these guys were hacked and passwords leaked.  And it turned out that they had used MD5 as the hash function for their passwords.
      [ Laughter ]
      So why is this a bad idea?  It's because there's a very famous attack called a dictionary attack that you can perform on a password that is hashed this way.  What you do is you have a dictionary, a large table of words or common passwords or some way of generating candidate passwords.  Then you take all the passwords, or the words that your candidate has, and run them through the hash function.  That's very fast.  And afterward look up in the table whether you could find  whether you have a hash that matches the password you're trying to match.  And then you have the plain text.  This might seem farfetched, but it's actually very fast to run.
      So here I have been taking the  oh, wait.  Is this going to work?  Yeah, it's going to work.  I have been taking the builtin diction that's pretty much on all index machines.  And I run the code that was on the last slide and we are going to try and crack my password.  And this is a shitty Mac book pro that runs on 1.2 gigahertz.  It was state of the art hardwarewise eight years ago.  And cracked my password in 1.3 seconds.  So rainbow tables are very powerful if people don't know what they're doing kind of thing.
      So problem.  Rainbow tables.  What can we do about it?  If a lot of people in the same database have the same passwords, they're going to have the same hash.  And research shows that a lot of people choose very common passwords.  So we are going to try and obscure that people have the same passwords, or make it very hard to generate these rainbow tables.
      So we want the identical passwords to yield unique hashes.  So how do we do that?  We use solid hashes.  So solid hashes make  so the way you do a dictionary attack is that you generate these huge rainbow tables because storage is cheap and you can go and buy premade rainbow tables.  So we want to make it impractical to generate these rainbow tables.  And the way we do that is that we solve the passwords.  So in this case  I can actually use  I generate a crypt graphically secure number of bytes and I go to the password and then the separator and then the password.  And when we store in the database, we need to  this doesn't have to be private, it's just a random value.  It's not random.  It's stored in the database.  Because the point is that if an adversary breaks your database and dumps the passwords, then you would have to generate a unique rainbow table for the users.  Because they have a random piece of data in the password.  And we can run this if we want to.  It's not too interesting.  Oh, wait.
      That's because I just  so  yeah.  Just goes like that.  Very fast and efficient.  And it's since we implement, here's the details.  I just chose 64 random bytes because all hash functions have something called block size.  MD5 has a block size of I think 512 bits.  64 times 8.  That's 512.  I don't know.  Maybe.  Something like that.
      So  yeah.  These are the offenders.  It's still very easy to break these solid hashes.  It was state of the art like eight years ago.  And I guess that's why it is still like common knowledge that it's okay to just install passwords, install them in the database.  But what these guys did is they used a fast and efficient hash function.  Some of them used MD5, still broken, still don't do that.  And some of them used the one that's now broken.  Don't do that either.  That can be forgiven in a way.  They still had eight years to migrate.  I don't know if that's forgiven.
      Problem.  It's way too efficient.  It takes too little time to crack the passwords.  You can go to Amazon and rent out one of their big servers and crack up the password hashing.  I saw benchmark for saltedsh1 with the tool called hash cap.  And it could do 2 million a second on the big server.  There's the sound again.  The big Amazon server only cost something like $8 an hour.  So when you think about cracking passwords, you have to think about not how much time does it take, you have to think about how many dollars does it cost?  The other day I read about a mathematician at a U.S. University working with the special curves.  And to study the curves you had to generate heaps and heaps of them.  To generate all the curves, he was trying to study took 60CPU years.  It sounds like a long time.  It took him just an afternoon to run 60 years of computation.
      That's where the intuition we have about time doesn't map to cracking passwords.  So what can we do about this?  Depends on money.  So we can try and make it less efficient to crack our passwords.  How do we do that?  We use is rated hashing.  It's one of the techniques you can use if what you're doing needs to be compliant, you can use a builtin function in Node crypt called PB  passwordbased key iteration function 2.  That's what we're going to do now.  The thinking with the hash functions, you give a password, but also a work factor.  How many times does it need to take the output to one hash iteration and use it for the next hash iteration and so on and so forth.
      And here we are going to use at  I want to use number five instead.  Oh.
      So you can see now it takes a bit of time.  There was the true, there was the false.  So now we are doing something like, I don't know, 200 milliseconds for every time you need to authenticate a user.  Now, an attack, instead of one millisecond per password or per hash, has to spend 200 milliseconds per hash.  And now those 60CPU years turn into a thousand CPU years or similar.
      This is what you need to do to use the PBKDF2.  You can see there's a lot of parameters you have to save in the database.  And a lot of things can go wrong.  What about the future when this hash function is broken.  All that stuff.  You need to choose an iteration count, how many times to run for risk.  How long a hash you want and what hash algorithm you want to use.  And pass that in, runs asynchronous in another worker thread and doesn't block the event loop.  And back you get an error on the hash.  I don't recommend you do this.
      Dropbox did this.  It's not bad.  I don't want to call them out.  They used Bcrypt.  It's based on a block cyber called Blowfish.  And the only issue with Bcrypt, kind of a nonissue, it limits the password to 72 characters.  I don't know anyone who would be able to remember a 72character password.  It's more of a problem with pass phrase instead of a password.  So the problem here is still that it's very easy to just run all these hash functions in parallel.  And that's the whole deal with the GPU is that instead of having one call with a lot of memory, you have like thousands of calls each with very little memory.
      And I'm saying memory and memory all the time.  I'm kind of hinting at what we can do next for even more money?  Spend all the money on hashing.  And now we are getting to what is kind of state of the art today.  And that is key iteration functions.  But a special kind of key iteration function that is purposefully slow because it both uses a lot of memory and a lot of computation.  And here we have it.  Argon2.  In 2013, the academic community kind of had enough.  Way too many breaches, way too easy to crack passwords.  And there was no one place you could point to just say just use this and forget about the details.  They made a competition.  They had a lot of entries, and argon 2 was their recommendation at the end of the competition.
      So let's fire it up.  So let's see  that's the number seven.  And you can see.  It's computing.  Take a long time.  Maybe it's taking too long a time.  So that's what I was saying about this.  There we go.  So that was the first verification, and now it's trying to verify the next one.  And you can see that it comes out there.
      Now, one issue is that  and I'll show that by showing you the code.  So the issue is that this is blocking.  I was trying to, when the hash function was spun up to authenticate, I was trying to log out.  I was trying to log out console with the hash to show you that the event loop wasn't blocked, but it was.  So that's kind of an issue.  If you have a server running with thousands of people trying to authenticate, then you only have one guy at a time authenticating.  And that's going to get your users very mad at you.
      So the good thing about this is I want to show you just the performance profile of the two functions.  So here I have the PBKDF2 in a file where I ramped up the iteration count to something very high so we have a chance to stop it.  It's a UNIX command to show how much memory and CPU a given process is using.  So I'm going spin up here.
      You can see that the Node processer is pinking the CPU at 100%.  But it's using 9 megabytes of memory, which isn't very much.  I mean, the top of the line GPU server at Amazon has something like 24 kilo bytes of memory.  I don't know how much it is  but it's a lot.  Heaps and heaps.
      So just kill this.  And instead let's go and look what the performance profile of Argon2 is.  So, again, I spun up the work factor.  Like heaps.  And let's try and run it.  And you can see now that it's, again, pegging the CPU, but it's also taking up 500 megabytes of memory.  So it's very easy to do the math.  24 gigabytes divided by 500, that's like 48.  You can do 48 of these cracking attempts in parallel, which isn't very much.
      So  nice.  But the problem is, there was blocking.  This is the  if you want to do the blocking stuff, this is how I do it.  I have a small library with one of my friends called Matias McIntosh online.  It exposes it as the PB hash function.  You can use it, but as you can see, it's a bit complicated.  So  yeah.  I was blocking.  What can we do?  We can make it asynchronous.  That's what you have done for you.  I have made it asynchronous.  All you have to do is run npm install and secure password and I'll make the password secure for you.  That's why I have the 
      [ Applause ]
      So you can use this today.  It came out like two weeks ago and I'm still adding in a bunch of other features.  One feature I'm still missing is because it's using so much memory it's actually a very real scenario that your box might run out of memory and the process will crash.  The system will kill it for you.  So I'm using  I'm still working on putting like a queue mechanism and you can check the queue and choose whether to bounce of the hashing tool, another machine or something like that.
      It's very easy to use.  Here all there is to it.  Don't need to think about salting or the work parameters or the algorithms or anything like that.  Think about forward compatibility.  It's very important when we do hash functions.  Because if there's a paper coming out tomorrow saying there's a reduction attack on Argon2, we want to switch to something else, maybe.  We can do that with this library too.  Doesn't get much easier than this.  I can just show you.
      So the parameters we ran it with before in blocking mode were high.  So the secure password, the default settings should be good for now.  They are set to what the backing library calls interactive settings.  So settings suitable for passwords on the web.  And if we run it, it's pretty fast.  You don't have to wait for several seconds to compute the hash and authenticate them.
      Now, we are running out of time.  So you can take this home with you.  It has a couple of options.  You can see in the readme what you can configure.  It's very easy to use and it has an equally easy verify function for you to use.  There's also a sync version in there if you want to use that, for command line stuff or whatever.
      So  yeah.  Wait.  There we go.  Thank you.
      [ Applause ]

