"You don't need AMP for that"
Chen Shay

    >> All right, all right, all right.  We had a little mental break to let everyone come from the other side of the conference to this side of the conference if they're willing to.  If you've ever wondered what AMP was, how to work with AMP, and how to make web faster through AMP, this is the talk for you, and it's really a pleasure to introduce Chen to the stage.
    CHEN: My name is Chen Shay and today I'm going to share with you, our secrets for making web pages fast and hopefully you'll learn some of the best practices and apply them in your own development process.
    But first, let me show you what problem we're trying to solve.  This is a typical mobile page, and I, as a user, want to see this page.  I have just clicked on a link to open this page and read the contents but I can't because there are things that are preventing me from doing so.  The first is that it's extremely slow to load.  In fact, does anyone here in the audience know how long it takes the average mobile page to load?  Fifteen seconds?  Fifteen seconds.  You know that after three seconds, half your users are gone.  After ten seconds, nobody's there.  Fifteen seconds is horrible!  The average is 19 seconds.  So after I finally loaded my page, I have this flash of unstyled content, which is very jarring, and could possibly give you epilepsy.
    And after I -- it takes forever to load, I have a flash of unstyled content, I start reading the page, and 20 seconds later, when the best part happens, this ad comes out of nowhere and shifts the content, and I don't know my place.  And I really want to know what happens next.  So then I try to look for where I was, but now my browser is kind of frozen, or it's janky, and I can't find where I left off.  This is a horrible, horrible experience.  We have all been here before.  But why should you, as developers care about this?  You have a million things you could be doing with your time.  Why is it important to fix these issues?
    Well, my answer is that it's important if you want to keep your users and your revenue.  Today I'm going to take you under the hood and show you what's going on that's causing all these issues.  I'm going to show you the ten steps that we take with AMP to address these issues to make the web experience much better, and hopefully you'll be able to apply what we do in your own development process to make your pages better and faster.  So, first, let's look at the first problem, which is that it's very slow to load.  And what's happening here is that there are things that are blocking the render.  And these things happen to be files that you have to download before you could see anything on your page, they could be CSS files, or they could be JavaScript files, and they take a really long time to download.  And we decided that everything needs to be asynchronous so that the scripts load in the background and they don't have to broke the renderer of your page.  The next thing is that we only want to download JavaScript that we only want on your page.  So here, for example, you'll have a carousel.  So not every page should download the JavaScript of a carousel.  So we break the page up into components and we tell the browser specifically what parts of JavaScript you want to download so that you only download the parts that you need for your page.  The next thing is that we inline CSS.  So external stylesheets tend to be very large and they take a very long time to load.  So inlining it means you don't have to download them separately and it's going to be a lot faster.  This is like taking a carryon when you fly.  It's faster than the people waiting at the carousel.  Nobody wants to be here because it takes forever.  So don't check in your luggage, carry it on with you, inline your CSS.  Now when you fly and you take a carryon suitcase with you, you have to limit how many things to bring, right?  Because you don't have room for your entire house in your carryon luggage and we decided we're going to limit CSS as 50 kilobytes.  Also, the 50 kilobytes, it forces you to get rid of things that you don't need.  And we have CSS for it, and then, we get rid of the -- we don't show it anytime because, you know, in January, Christmas is over.  But someone forgot to clean up the CSS.  It's still there even if your users don't see it.  But they're paying for it with their time because it takes longer to download and they're wallets, because this takes up data.  So limiting CSS to 50 kilobytes means that you're going to have to clean up these things and it's going to give your users a much better experience.  The next thing I want to talk about is third-party JavaScript and mainly in relation to ads.  So ads have not all kept up with the times, and a lot of them think that they need third-party JavaScript for their executions.  And because ads are important and they make money, we have to allow them to exist and so they use third-party JavaScript but we have to tell them -- they need to be in sandboxed iframes because third-party JavaScript does horrible things.
    First, they write sync scripts.  So, again, you have this issue where you have to wait for these scripts to load where you could see anything on your page.  The next thing is they document.write more sync scripts.  So you have more sync scripts that you have to wait for and it all adds up.  And then the third thing that they do is style recalculations, which is very heavy on the CPU because they have to scan the whole page, and they could be wrong because if you change the CSS wrong, you could change something on your page such as your logo.  And you don't want that.  So by limiting to sandboxed iframes, they're not going to affect the page, they're not going to affect their load and they have their little box where they're going to play.  And doing style recalculations is going to be a lot cheaper because it's only going to scan the contents of the iframe rather than your entire page.  This is, like, allowing your toddlers to play with paint.  You know that they're going to make a mess.  You just want to keep that mess away from other parts of your house.  The other thing we do is resource prioritization.  So a typical mobile page is a lot longer that your viewport, that your first viewport of a von.  And sometimes we don't actually download the entire page when a user taps on it but the user perceives the load to be instantaneous because we load the contents in the first viewport before we load the rest of the page.
    And this makes the perception of the load instantaneously even if we didn't have the time to download everything.  And we also do something called preconnect.  So, for example, here's a YouTube video, and to load the content of a YouTube video, there are a lot of things going on, but one of them is we have to connect to the source, right?  We have to connect to YouTube.  And that takes up time.  So by connecting ahead of time, if we know that there is a YouTube video, or an image, or, for example, with Twitter, to load the, you know, the content, you have to connect to one server to load images, you have to connect to another server.  By doing these connections ahead of time, when it comes time to load the contents, it's gonna load much faster.
    So now we've gotten rid of this slow-loading problem but we're not done because we have this flash of unstyled content and we don't want this.  And what's happening here is that the page is loading, but then the styles are being applied after the page has loaded, and to solve this problem, we use an invisibility trick and we set the opacity of the body to zero.  So it exists but it's invisible to the user.  And then, the styles are applied and, eventually, the JavaScript will load and unhide the page.  So to the user, it's perceived as being loaded like this first.  But what happens if there's no JavaScript?  Well, we have this noscript to unhide the body if there's nothing to unhide the body.  And then, finally, what if JavaScript servers go down?  Which can happen every once in a couple of years, right?  And to address this issue, we do a CSS timeout, animation timeout.  So if, for some reason, the page thinks there's JavaScript but the server times out, then we will have a timeout that will unhide the body if the JavaScript never arrives.  Now what I just described to you, it's what we currently do but there is a bit of a time delay and we're currently working on doing server-side rendering so that there would be zero time delay.  So now we load fast, we've gotten rid of the flashed unstyled content but we're not done because 20 seconds into reading, this ad loads out of nowhere and shifts all the content all around and nobody likes it.  And what's happening here is just like I talked about earlier that ads use these third parties, JavaScript that runs really slow, we can't force all the ads to be implemented in a way that if we're together to load fast.  We can't force them to do that.  But to solve this problem when we let them exist, but not punish our users, we let them put these placeholders because we know that there's going to be an ad, and we have abstract resource sizing.  And so we know the size of the ad, and so the user can read the content of the page and then it's up to the ad to load on time.  So the user can continue reading and have a pleasant experience.
    And we've solved this content-shifting issue but we're still not done because we need to address this frozen, janky problem that's happening.  And what's going on here is that the CPU is overworked and overloaded and to address this, we do a few things.  First is that style recalculations are really expensive.  So we want to minimize style recalculations and we do so by caching the coordinates so we know where all the things are, and then we know when things resize and that's the only time we're going to recalculate the style.  Also, we batch the DOM access.  So, for example, I have this code sample where we measure something and then we set the height to change the DOM, and then we measure something again, and then we change the DOM by setting the width and then we measure something again and this is a very reasonable chunk of code.  But what's happening here is that the style is being recalculated every time you measure something because the dome has changed.  So by batching the dome access, we can schedule a read for the first animation frame and then we can schedule a write for the next animation frame so that you only recalculate the style one time in this example and this is going to be a lot less expensive for the CPU.  So we have a max of one style recalculation per frame, and this is the main thing that makes AMP pages fast when you interact with them.  This is really the only thing that you can afford if you want to get to 60 frames per second and we only do two style recalculations for a page load, which is very low compared to other pages.  The next thing is that we want to do GPU optimizable animation only in our AMP components.  So animations are very expensive for the CPU and we want the CPU to hand over the work, to delegate the work over to the GPU, because the GPU can do animations really cheaply, and really quickly.  So in our AMP components we only allow animations that the GPU can perform.  And in this case, it's transform and opacity.  So if you wanted to animate the width, the GPU is not going to know how to do it and it's going to say, CPU, you go ahead and do this.
    So we don't allow width of height animations, but we do allow transform and opacity because the GPU knows how to do this, and it can into it very cheaply.  So we've gotten rid of the frozenness and jankiness but I want to take a moment, everything that I've talked about any developer can do.  You can apply in all of your development processes but because we're talking about AMP, AMP also use a cache.  So if you wanted to build a system, it's a little more complicated but you can optimize with cache and what we do is, first of all, the cache, we have servers that are located in lots of places all over the world.  So they're physically located next to you and that means that delivery of the content is going to be a lot faster when these servers are located next to you.  And these could be Google servers, or they could be Cloudflare services.  And the things that we do on the cache, first is -- so they used to have this thing where it's called re = treeRender where you would have have this thing on the page and you would say preload the link.  When the user would click on the link, the page would load instantaneously but the problem with this was that it downloads the entire content of the page, the images, the ads, and it would execute arbitrary JavaScript in the background and that's very heavy for the CPU.  So, instead, what we did is we prerender only the first viewport.  And we don't execute any third-party JavaScript.  So none of the analytics and all that stuff.  And what this does is it makes prerendering extremely cheap and non-expensive.  The next thing we do is resource compression.  And by resource, I mean all the things, all the files that the users are going to download onto their page.
    And some of these files are JavaScript files and so we use a closure compiler to compress our code.  And here's a chunk of code on the left and if you run it through the closure compiler, it's going to compress it to the chunk on the right.  And on top of that, oh, it also does tree shaking.  So it gets rid of dead code and methods that aren't being used and so on.  And we have our own optimizations that we do on top of the closure compiler.  So we get rid of developer code such as logs that you only use for development but your users, they shouldn't have to download those logs because they're not going to be useful.  So we've gotten rid of those, as well.  On our main page, so on the HTML, we use a compression algorithm called Brotli and that saved us 8% over gzip which is another compression algorithm.  And then finally I want to talk about images because images make up 64% of the bytes of an average mobile page, that's huge.  So if you can affect images, you can have a huge impact on the size of the page.  So we compress images.  The first thing we do is remove invisible data.  This is metadata that your users don't see such as geolocation and so on.  And we also reduce the quality of the image and we try to have -- we convert the images to web P and that converts the images further.  And then for Chrome users, for places in the world where data is extremely slow, we lower the quality of the images even further to save more bytes so now when we apply these three things on an image, let's look at the before and after, so before we have 2340 bytes and put the right image has two 500 bytes.  And you might look at it, and say I don't like the image on the right, it's not as good.  I could tell the difference but I want to tell you that, actually, I switched them.  So the image on the right is the before, the image on the left is actually the after.
    So now, to summarize everything, if you have haven't paying attention, or if you just walked in, to make web pages faster, we want to unblock the render by making sure that scripts are asynchronous so you don't have to wait for them.  You want to bring your CSS with you, and you want to inline it, and you want to limit it to 50 kilobytes.  And third-party JavaScript is okay but you want to put them in iframes to they don't affect the rest of your page and you want to prioritize your resources.  You want to load the things that your user is going to see first.  Also we use opacity magic to make sure these things don't happen and we're going to do server-side rendering in the future so that there isn't even a tiny bit of a delay and you want to stop shifting by having placeholders and static resourcesizing.  And then you want to unfreeze your page by giving your CPU to breathe.  Let your GPU do the animations and if you can do cache optimizations, do cheap rerendering and compress your page.  So let's see how we're doing.  Nineteen seconds for the average mobile page to load and less than one second for AMP on search.  And what does this mean?  Well, it translates to 10x plus data.  We have higher CTR.  Publishers are seeing higher CTR and viewer visibility.
    So, hopefully, if you apply some of these things, you can see similar benefits, as well.  And if you don't want to do all of that work, you're welcome to use AMP.  Now, I know this is JSConf, and you all love JavaScript so you might not want to use AMP because it doesn't involve writing a lot of JavaScript so I'm here to tell you that you're welcome to write progressive web apps and use AMP for content delivery and that way, you can write lots of fancy JavaScript and if you're passionate about what we do and you want to help out, AMP is an open source project and so you're welcome to work on the project with us, and create AMP components.  To learn more about the AMP Project, please go to ampproject.org, if you want to contribute, Bitly/amp.  And if you would like to learn more, we'll be at the booths and you can meet with our team.  Thank you.
    >> So many awesome talks.  They're never-ending.  I don't know what to do with myself anymore.  It's time for another coffee break.  Go so the Community Area, and there's -- you can chat to open source projects and initiatives, and representatives.  It's really alive, and going and kicking and so if you have haven't checked that out, please go and talk to those people because all of them are awesome and working on really interesting stuff.  See you in a half an hour.
    
    [ Short Break ]