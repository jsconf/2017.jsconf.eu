Outbreak: index-sw-9a4c43b4b4778e7d1ca619eaaf5ac1db.js
Alexander Pope

Live captioning by White Coat Captioning
REMY: Okay, I can see some people trickling in at the back.  Run!  Grab your seats, hurry up.  Quick, we are about to start.  There you go.  Okay, so this is really loud.  This is the last talk of this track, and we've got a nice kind of horror story about zombie - I'm not going to read out the title of your talk because it's a full on hash of characters, so yes, zombies, service workers, and storytelling to get us in the mood for the end of the day, so please welcome Alexander and yes, get ready.
ALEXANDER: All right.  [Applause]
There we are.  Do we have some music?
There we go.  Hello, welcome to the last Side Track event.  My name is Alexander Pope and I'm really excited to be here today to share this story with all of you.   [spooky music]
It's a scary story so I hope nobody has a weak stomach, and like the scariest stories, it's all true.  Mostly.  I'm going to try something here.  I am going to try and actually say the title of the talk.  
This is Outbreak: index-sw-9a4c43b4b4778e7d1ca619eaaf5ac1db.js.
[Cheering]
If this wasn't attached to my head, I would just drop the mic and go, but I have a story to tell and here we go.  In the corner of a functional though charmless open office, Alexander sits at his desk staring intently at the screen.  A phone rings in the background, momentarily disrupting the early morning stillness.
 [Inaudible announcement]
The following morning, in a cramped meeting room, Alexander enthusiastically sketches on a wall-mounted white board.
 [Inaudible film]
>> Alexander, we hope you are aware ...  [inaudible] something is broken.  Fix it and ship it.  Just change something.  Within 24 hours at least.   [inaudible].
ALEXANDER: Days later, Alexander hurries, cleans up commits while rebasing a git merge for release.  The desk is littered with disposable coffee cups.
 [Inaudible film]
>> Alexander, have you forgotten about something? 
ALEXANDER: Several weeks passed.  In the quiet of a darkened living room Alexander anxiously scans error logs.  Notification alerts pierce the silence.
>> Function ... I don't get it.  How can that all be ... this specification is unstable, as you are well aware.
>> Shut up.  Focus.
ALEXANDER: One week later, back at the office, Alexander puzzles over the latest error logs.
>> That's weird. ... it's just not possible.
ALEXANDER: More weeks pass.  Visibly tired and distraught, Alexander slumps over his computer at the dinner table.  A baby cries in the background.
>> This is starting to freak me out  [inaudible] ...
>> Don't be ridiculous, in a year or two ...  [inaudible from film] ...
ALEXANDER: Ooh!  That gives me chills every time I think about it.  Permanently installed, that is a horror story.  You know, there's something strangely compelling about a disaster story.  Sometimes it's the disaster as an act of God, other times it's man-made but the best of them have this in common: the central characters are faced with difficult, sometimes impossible moral dilemmas.  As viewers we ask ourselves how we would behave in similar circumstances.  Could we handle the pressure?  Would we make the same choices?  Would we do the right thing?
Some of my favourite disaster stories are about epidemics, or disease outbreaks that threaten humanity: think Night of the Living Dead, 28 Days Later, 12 Monkeys, Children of Men, and many others.  Many of these stories and the entire zombie genre in fact were inspired by the book I Am Legend by Richard Matheson.  The book has been adapted three times for the big screen and my favourite version is The Omega Man from 1971 starring Charlton Heston.  I love it because it is just so 70s.  And Charlton Heston just can't stop delivering cheesy one-liners, no matter what happens to him.
 [Inaudible film]
ALEXANDER: The antagonists in this version are more human than the vampires and zombies of the others, and I like that this cult of albino mutants spends all of its time raging against the science and technology that they blame for their fate.  In most zombie stories they don't plan on turning people into zombies, it just sort of happens by accident and it's usually because technology goes a little bit out of control.  Now, as I struggled against my own mob of zombie service workers I realised that there is a real risk of triggering technological backlash.  Now, as web developers we are constantly tempted to throw more and more technology at the problem but if we aren't careful we might end up pissing off our users, making things that are slow, annoying, inefficient, insecure, or even just full of bugs.  It really risks alienating the people we are trying to make happy.  Now, for the next 11.5 minutes things are going to get a little serious.  Not like, "Oh my God, this is serious!" kind of serious, but more like the grown-up kind of serious.  There will be a lot of information that may or may not be relevant to you now, but don't worry, if one day you find out you need it you can always find it on GitHub.
Before we first go too deep, just in case some of you are wondering what the hell a service worker actually is, here are the basics.  A service worker is a script installed via a web page that runs in the background.  It gives you the power to control asset caching, to handle requests from pages and workers when offline, and to respond to incoming push notifications.  Service worker is a type of worker, so it doesn't have access to the DOM, AJAX or local storage but it does have post message for communicating with clients, fetch for accessing the network and IndexedDB for storage.
Service worker has a life cycle which starts with registration, when the file is downloaded and executed; it then enters the installation phase when the install event is triggered, and if there is already an older version installed and it's actively controlling clients, the service worker enters what's called the waiting phase until all clients have disconnected.
When it's safe to start controlling new clients the activate event is triggered and the service worker enters the activation phase.  Finally, when the activation phase is over, the service worker is known as running, and able respond to client network requests via the fetch event handler.  Now, service worker also has new toys including a cache API for storing network requests and responses, a clients API for managing connective clients, which are pages and workers, and a push API for managing push notifications from remote servers.
So with that out of the way we can get down to business.  How do we avoid the next zombie apocalypse?  Or here are some things I wish I had known before I started with service worker.  Rule number 1, in no particular order, understand how promises work but don't use them, use async/await if you can instead.  Using async/await can really help make things more legible.  Although very few browsers support native async/await, it's just syntactic sugar over generators and promises, and every one that supports service worker will also support async/await.  Using Babel with the async-to-generator plugin will do the transformation for you but be aware that this code cannot be uglified - you should use Babili which is another plugin for Babel that you can use for minification instead.
Two, don't use while the page is loading.  Wait for the window on load event or some other signal before registering.
Rule number three: know your dependencies.  During the installation phase, passing a promise to event.waituntil will delay service worker activation until it's resolved.  However, if it's rejected, the service worker will be thrown away and marked redundant.
Now, since the installation phase is when you want to pre-cache all your assets, any asset that fails to load will cause a rejection.  In this sense, you can think of pre-cached assets as hard dependencies, so you should beware.
Rule number 4: cache smarter.  When upgrading a service worker, it's common practice to pre-cache assets in a new, uniquely named cache before deleting any old caches during the activation phase.  Now, in most cases this is a really good approach but if you release very often you can avoid wasting storage and bandwidth by only fetching new assets and then recycling the old ones.  Now you can first create more than one cache to separate versioned assets from those that won't change, and copy versioned assets from the old cache if they already exist.  Now, obviously this is not as neat as cache at all, but it is much more efficient.
Rule number 5: avoid forcing activation for major changes.  Forcing activation after an update can break already connected clients if the new service worker is very different from the old version.  So you can avoid calling self-.skipWaiting after a major change and consider actually prompting the user to trigger a manual refresh, and that way there won't be any breakage.
Rule number 6, use a library for messaging.  Sending messages between a service worker and its clients is actually kind of weird.  The API is a bit hard to work with but using a library like Swivel makes it a lot easier.
Number 7: never rename the service worker file.  Once the service worker has been installed and activated, it will need to be updated, of course, but often we cache the HTML file that triggers the registration so it would be difficult to install a new service worker if it had a new name from that HTML file.  So you can avoid this chicken and egg problem by making sure that the service worker script file name is never unique, it's always the same.
Along with that, rule number 8: you have to set correct cache headers because, of course, if the service worker script file names are static and the browser fetches the script through the browser cache before going to the network you will need to correctly set cache control headers to prevent the browser from caching outdated versions.  As a precaution, to avoid accidentally installing a service worker for days, weeks or months, caches will be bypassed if the script is older than 24 hours, regardless of what you set.
Now, cash invalidation is always tricky as we know, so in the future browsers will be using cache busting always by default to ensure that the service worker script files are always up-to-date.
Rule number 9: invalidate your service worker when updated.  The service worker will be updated if it is byte different from previous versions.  Now, a simple pattern you can use to treat the service worker as a boot loader by using import scripts and version dependencies, and that's all you have to have in your service worker file.
Rule number 10: add a feature flag or kill switch.  This one is important.  Having an easy way to disable existing service workers is a life saver really.  Add a feature flag to control on registration.  Keep a no op service worker handy in case you have to have a quick deploy, or even better, have a service worker phone home to check its version then force an update if it's outdated.
Rule number 11: don't cache bad responses.  You should always check the ok property of the response object returned from a fetch call before you add it to your cache because HTTP response codes, they don't cause the promise to reject.  So you have to manually check.
Rule 12: don't store global state.  Storing global state in a service worker is really bad.  Bad idea.  Because code outside of the event handlers, like install, activate and fetch, they run each time the service worker is started, but the service worker is stopped and started many times over its lifetime as the - yes, the device manages battery and other resources, so it's really important not to store global state because it will be destroyed at unexpected times.
Rule number 13: guard against missing APIs.  A number of API methods were added in later browser versions, so it's wise to test whether they exist before calling them.  The following methods were added in later versions of Chrome, for example, after service worker was launched.  Rule number 14, this is an important one too: test your service worker.  Now, because of the installation life cycle and the unique environment that they run in, service workers are really difficult to test.  As always, running tests in real browsers with real code is going to give you the most realistic results but unfortunately there aren't yet any good tools to help with browser tests.  But the methodology well laid out in this article by Matt Gaunt of Google.  Highly recommended.  Now, automating browser tests comes with its own set of challenges as some of you will know so it's best to test as much as possible.  Fortunately there are some tools available to easily mock and test service worker environment.  As part of their service workers tool chain Pinterest has developed helper functions and a mock you can use to make the Node.js global look more like a service worker.  I've also released a project called sw-test-env and it's a little more thorough mock of the service worker environment and allows you to run scripts in an isolated sandboxed context.  With it, you can inspect the properties of the service worker scope, manually trigger events, post message between clients and service worker instances, use import scripts, fetch real or mocked data, use indexedDB storage and require modules from inside your service worker file without a build script.  Now, here is an example from one of the unit tests I wrote for my slides because I write tests for my slides.  First, we load the service worker file; then we create a populate an old version of the cache.  Then we trigger the install phase; and finally we read from the cache to verify the old version has in fact been recycled.  Now, I think it could be a really useful tool so if you get the chance, take a look and let me know what you think.
Finally, rule number 15: use a service worker generator tool.  If you don't want to get your hands dirty with all these details, you can use one of several service worker generator tools.  There are lots of good ones out there.  But you should still write tests.
So, now that we are educated, you might be wondering what happened.  What was the recipe for this disaster?  Simply, it was one part ignorance, one part stupidity and one part mystery.  Now, we know that versions of Chrome before 46 didn't support cache at all.  So any client missing that API should have caused the promise return to the install event to reject with a syntax error.  Undefined as not a function.  Unfortunately a catch was also added to the promised chain in order to report install errors, but the error was never thrown further up the chain.  And the service worker was installed instead of thrown away.  That explains how some clients became infected with a broken service worker, and based on the number of errors reported it's clear that most of the infected were soon cured, but it's still a mystery to me as to why or how a small number became permanently cursed.  Now, even after trying to install an empty service worker, then eventually a kill switch to unregister it completely, that broken file still haunts me and probably will until every one of those devices is retired.  [Laughter]
Now, even if the details are lost on you, I hope I've made my case that service worker is a complex beast.  It is awesome, but it's kind of awesome like the way a chainsaw is awesome.  [Laughter]
It's really powerful, and really easy to lose a hand, a foot, maybe some toes.  But don't be afraid because a lot of people use chainsaws every day without spilling blood.  They take precautions, they dress for the job and they read the instructions.  Now that I know more, now that I have some tools for testing, I'm ready to get back into the lab and I hope that everyone here is also ready because service worker really is the best thing since AJAX and I know everyone remembers how that turned out.  So thank you and remember to kill your bugs and zombies but not your dreams.  Thank you.  [Applause]
REMY: Awesome stuff.  Yes, really, really good.
