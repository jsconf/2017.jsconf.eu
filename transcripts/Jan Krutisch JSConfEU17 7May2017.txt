AEsthetics of code
Jan Krutisch

Live captioning by White Coat Captioning

REMY: So next up we have Jan.  If I've managed not to kill that.  I just told him a minute ago I just read the description for this talk where he is basically going to tell us that all our code looks ugly as hell and why he can give us the best aesthetics for our code, so please give Jan a warm welcome.  [Applause]
JAN: Thank you very much.  It's always an honour to speak at this conference, and for me it's the second time, that kind of amazes me.  Anyway, so how many of you have actually read the description of the talk?  Okay, so there's this thing in there where I say my presentation will contain nothing but code, and as you can clearly see I'm already tricking you because this is actually code.  You can take this, you can execute it in your browser console and it's thanks to works of a friend of mine, Martin Kleppe, who presented this at JSConf 2013, and it basically turns arbitrary JavaScript code into this weird thing that only has six different characters, I think, and it's completely oblivious to white space, so I was able to turn it down into these things that actually resemble title slides.  And I was speaking yesterday to someone who mentioned that in the title on the schedule page, there's actually - I was using AE, like the Danish use all the time, and it's not in here because I didn't have it in my talk title, the organisers came up with it and I thought I need to fix this but the problem is that encoding that takes up a lot more space so it doesn't really fit the title screen.  Speaking of Martin's work I just want to quickly point out what I don't really want to talk about.  First of all, this.  You can look it up.  It's maybe aesthetic in its own way but it's not very practical probably, and also this is not practical.  I love this.  It has also been presented as JSConf 2013 and it is very beautiful, it has its ownaesthetic but again is not very practical.  You can learn a lot by analysing what Martin does here but it's not very helpful for day-to-day stuff so I'm going to talk about other things and the first thing I want to talk about is programming languages versus natural languages, and if you have been here on the talk before mine, there was this idea of turning natural language into something that computers can understand, and I find this approach very cool.  I think it makes sense to always keep in mind that programming languages ...  [sound problem] ... can turn natural language into something that computers understand.
 [Sound problem] ... pretty controversial example.  So how many of you know what this is, where this is from?  So this is the official npm coding style guide, a talk of it, which talks about the comma first syntax.  Don't yell at me yet.  So I find this interesting.  I find - so I personally completely, you know, I would never write this this way.
But for me it's just a different set of - yes, I don't know, conventions that have different drawbacks and different benefits from what I would normally write, so I don't have a huge issue with this, but in defence of this I read a blog post that some of you may have read at the time, it's pretty old, where he says - I'm paraphrasing - don't compare JavaScript to the English language.  JavaScript is not English.  So the argument that punctuation should be at the end is silly.
I read that and had a pretty strong reaction because I think this is a weird way of thinking of this.  We as humans are used to reading natural language every day, of course as programmers we are used to reading programming language every day but I think most of the programming languages are modelled after things we have in natural languages as well, and that makes a ton of sense so to me that argument was kind of: no.  The irony in the story, of course, is that I wanted to - because this is just an example from the style guide and then I wanted to look up actual  [sound problem] ... and I was in for a surprise because I don't follow that very closely, and obviously since 2015 ... interesting, but the coding style is still out there so if anyone from npm is here that might be something you want to look at, more maybe I should - I don't know.
So speaking of closeness to natural languages, here is an example.  I'm a Ruby programmer - I'm sorry, don't shoot me.  I also write Ruby.  And to me this is a perfect example of how a language can look like that tries to mimic natural language in some opponents.  Please ignore the puts.  Puts is a terrible choice for something - you know, what does that even mean?  But ten times do, and then do something, that's something I can show to - I almost said my Mum, which is terrible.  Don't do that.  So you can show that to anyone who is not familiar with programming and it will make sense to them, and so I think this is a very elegant example, a very aesthetic example of how code can actually look, and just an exercise for you to do in your head: turn this into JavaScript.  You would probably use a 4 loop which is one of the constructs in JavaScript that probably resemble natural language the least, I would say.
Another example.  This is Python.  I could have chosen CoffeeScript but I didn't want it upset everyone in the audience, so Python is one of those significant white space languages and interestingly I looked it up on Wikipedia, and it is termed offside languages.  Who has heard that before?  A few people.  Explain that to an American who calls this thing soccer; interesting choice of words.  Anyway, I just found that funny.  So the thing I want to point out here is in slightly modern typesetting, so since we are doing typesetting, we use indentation for grouping and categorising things, for building a hierarchy of things, and the one thing that we never do in typesetting is actually writing something at the end that kind of closes down that block.  You never do that.
So I think Python made an interesting choice and it works for Python because it turns this thing into something that is still pretty good to read and it follows a convention that has been set a few hundred years ago of how to do hierarchies.  So there's two problems I see with these kind of languages and the first one is actually probably not a problem, so at some point I don't know if he has coined that, but DHH, the creator of Rails, used the term syntactic vinegar and I like that term, so if you imagine you have code that longer than your screen in a language like this and you scroll down and suddenly it's like: where am I?  Where does this close?  I have no idea.  I'm completely lost in indentation and so the language or the syntax punishes you for actually doing a thing that you shouldn't do in the first place which is writing long functions, and I found that kind of interesting.
The other issue I have with it is that, to me, it always looks a little bit like this.  So it's kind of off balance in a way.  It never returns.  This is weird.  So yes, that's significant white space.
This is interesting, so just a quick show of hands, who likes the first thing better?  Who likes the other thing better?  Okay, everyone else doesn't have any reaction to that, which is fine.  So to me at first this was - that's the JavaScript way and the other is the Ruby way.  There's a complete family of languages like Ruby, Python and others that join things together with an underscore and there's a whole family of languages that uses the camel case kind of thing.  What's the difference?  Turns out there's a study - I only found this one, but interesting enough - that kind of tried to find out which works better in the context of how precise can you - how is the precision of detecting things and how quickly can you actually read this?  And it turns out that snake case is same precision but significantly faster and to me after thinking about it for a minute that totally makes sense, so if you know how the brain and the eye together parses words and sentences, you are not reading character by character, you are basically reading shapes of words, and so making out the shapes of the words in a functioning like that is significantly harder if you just jam them together and put some large characters in there.  The underscore actually looks pretty familiar to the human eye because it's almost like a space, and there's almost - the underscore almost takes up no room so there's no shape to detect in a way.  That's my own almost unscientific explanation for it anyway.
So why did languages choose one or the other?  That's an interesting question.  I have no answer for that, of course.
To close this down, here is something, you know, that's from an example from a blog post that I read during preparing for this talk by Joseph Wynne who talks about readability in code and this is another thing where actually, you know, thinking about how we write natural languages can help a lot because this for some reason is completely more readable.  You have all the blocks in there and you just use paragraphs.  You know, it's a very simple thing and it might sound really mundane and trivial but I have seen code bases where this rule wasn't applied and I don't mean Martin Kleppe's stuff with that, or minified code.  The second thing I want to talk about really quickly is the principle of least surprise, which is something that influences language design up to a point, and I have a very terrible example for you that you will all know, like who in here knows what's going wrong with these lines of code?
Come on, show your hands, please!  OMG.  So all of these things are complete garbage.  They parse into things you don't want them to be parsed into and they will all balk out with terrible errors.  Why is that?  Because - I mean, it's JavaScript, so JavaScript wants to have semicolons at the end of every instruction.  Do you see any semicolons in here?  Well, I don't.  It's, of course, okay to write it because we have this awesome feature called automatic semicolon insertion, or ASI.  The problem is there are a few cases where the ASI stuff simply doesn't know what to do, and in this case I mean the worst example is like the one in the middle where it turns it into a division because, you know, there's a variable and then there's a slash, so there must be a division, and then everything goes wrong, of course.  To me, this is like JavaScript's Achilles heel in a way because to me, from an aesthetics standpoint, all of this looks totally fine.  I've seen in your reaction that you think too this should be valid code, but other languages simply have different syntax rules that make sure that something like this doesn't happen, and JavaScript at some point decided that it's okay to say: okay, we need semicolons but then we don't but then there are weird cases and that makes it really hard to look at this piece of code and say, "This is wrong", or, "This is right", and if you are an experienced JavaScript programmer or if you are exlint for example, you can say it and say this is wrong, and you can balk out and say: please change this.  One way is to prefix all the second lines with semicolons.  Looks really beautiful.
So another trivial thing, so I like to close down the blogs with trivial things obviously, if you can see it, what's wrong with this?  Does this really calculate a sum?  No, it doesn't.  That's like the most trivial example for validating the principle of least surprise that you can probably come up with.  It's like: nobody would do that, right?  But then you just think about it, how it happens, and code bases, and you have this method or a function that does a certain thing and you use it in 30 places all over your code and then a new business requirement comes in and you kind of slightly change the function, that it does things a little bit different like not changing from a sum to a difference, but something more subtle, but the name only half matches what's going on now.  Do you really want to go into 30 places and change the name?  Do you have automatic tools for that?  And so that's just - don't do that.  Don't leave it in like that.  Change it to something that's correct.  That's what I'm going to tell you.  So who knows what - just out of curiosity, who knows what language this is?  It's Louvre  [?] so you know, function and then this weird looking syntax.
Number three, expressiveness.  This is one of my favourite subjects.  I like expressive languages so that's why I'm starting with this.  Who knows what this is?  Hands up, shout it at me?  Exactly, it is the syntax definition for Lisp.  It's pretty small, isn't it?  That's amazing.  So there's this other thing I want to show you.  Don't bother to read it.  This is a parser definition for the Ruby syntax.  It's not like the parser definition., it's just a library that parses Ruby into abstract syntax trees, and I already sped that up two times.  It's like 2500 lines or so.  It's quite different to Lisp, isn't it?  So now we are done.
Now let's look at some code examples.  This is like the prototypical Fibonacci sequence definition for Lisp for recursive Fibonacci calculation.  And I'm not used to Lisp so I look at this and go: hmm, I don't think I like this very much, and to me it's like, you know, if all you have - lists - everything looks like a hammer.  So yes, it's very uniform and if it wouldn't be correctly indented it would make no sense to me.  Interesting thing though about the indenting, because Lisp syntax is so simple, it's really trivial to build a tool that will autoform a Lisp code for you which is almost impossible for Ruby code, for example.  So here is the Ruby example, and to me as a Ruby programmer, and probably also to you as a JavaScript programmer, this makes a ton more sense so there's syntax to define the end and the beginning of a function.  There's syntax to return something, there's an if thing which is kind of weird for JavaScript programmers, but it's like inherited from Perl and I don't particularly like it but it works.
Yes, there's just so much syntax in there in contrast to the thing before that I think it just goes to show that while Lisp people always say that having syntax actually makes things more complex, it also makes things more readable, I think, for the most part at least.
So here is another example.  This is an incomplete example before you yell at me for something that could happen, in Ruby on res, for example, and it's a definition for a user table or a user object that has a relationship to photos, so users have many photos, and this looks - to me, this looks quite elegant and it looks like a declaration.  There's a reason for that because there are - the method call that is in there technically doesn't have the parentheses around it and that's a Ruby thing.  You can just leave out the parentheses.  You shouldn't do that all the time but for something like this it makes a ton of sense because it is a declaration more or less, but technically internally it isn't.  That's just an example to show you how flexible syntax rules can really improve the readability and the expressiveness of something.
The next thing I want to talk about is punctuation.  Who recognises the language in here?  Yes, exactly.  So this is Pascal.  I'm sorry, it's - the most important thing is at the bottom.  I should have changed that slide.  So there are two things in here that I find interesting.  The first one is the assignment operator of Pascal.  Who loves the assignment operator in Pascal?  Right.  Because it is a mathematically somewhat adequate description of an assignment whereas if you compare two values in Pascal you are using the equals sign, which means that something is equal, and for some reason in almost every other language we do this weird thing where we use two equals sign for comparison, or even three, and that's kind of - yeah, I like that.  The other thing is right at the bottom, and I'm sorry if you can't see that, but there's a full stop at the end of the programme.  I just admire that simplicity.  It's like: end, full stop.  That's it.  Punctuation.  There are a few languages that use punctuation - I'm sorry for another Ruby example.  You have one which basically adds an exclamation mark to the method and most of the time it's a version on a method that does something more dangerous than another method, in this case it's the self-modifying method in contrast to a method that would return a copy, and then we have the question mark methods which denotes that it will return and that's nice because it allows you to return things like "is empty" or "does not have contents", and all jammed together with camel case so that's pretty cool.  You can, of course, put this completely over the top and then you would end up with something like this, so who knows what this is?  It's the programming language.  Actually, it's "a" programming language, it's APL.  And it's a very old language and it uses all kinds of mathematical characters to express things and just think about how weird it would be to input this language, and so back in the days, that was before computer screens were really a thing so they had to come up with a printer head that would be able to print these things and of course also you needed a special keyboard to be able to put this in and, yes, that's probably overdoing it a bit with the symbols there.
Another thing that improves expressiveness is operating overloading and I don't even have an idea if this is really operator overloading technically, but in Ruby you can just overwrite the array accessor and that's pretty nice because you can do various things with it.  There are other languages that do operator overloading.  If you haven't heard of - like, who knows what this is?  It's a language that has been talked a lot about a few years back and I haven't heard a lot since.  It's Dart, and Dart has operator overloading.  That's how it looks and it's pretty nice because you can just take two objects, add them together and something meaningful comes out of that, and that just makes for more beautiful code, I think.  This is Ruby examples again, like having - being able to do a substring on something just by adding square brackets to it.  I think this really makes a difference in how expressive a language is.
Number 4: shared aesthetics.  I am going to close out with this.  So there's lots of stuff I have talked about and I have also talked a lot about - I've written in my description that this thing - Remy was talking about, like, nobody agrees with you in terms of aesthetics.  I have something that we probably all agree on.  And that's that this is probably not a good idea.  I stole this from a tweet.  I kind of like the attitude behind this.  Like, you can actually write Java code without curly braces and semicolons, except that you can't.  Yeah.
I see from your reaction you are agreeing with this.  What I find interesting about the JavaScript community though is that there doesn't seem to be a strong shared understanding of how JavaScript should look like.  Other languages do it a little bit differently.  For example, we have Python which has in PEP8 - PEP is like their proposal system for new language features and PEP8 is obviously one of the first texts written by the man himself, Guido, and it writes meticulously how you should write in Python, how you should index things, all that stuff, and if you are a newcomer to Python you just read that thing and internalise it and you are done.  That's pretty cool.  You might not agree with everything in there but that's how things are done here so maybe that's not so bad.  We have a similar thing in Ruby.  It's the community style guide.  It's not really official but people start to adhere to it due to the fact that the guy who wrote the first thing here also wrote a pretty good linter.  That's a nice trick.  So in JavaScript we have something like this, which is the Crockford style guide, also relatively detailed, how you should write your JavaScript, and I guess like 90% of the community nowadays disagrees with it, which is fine.  Then we have this, Standard.  Who loves Standard?  Ah, just a few hands.  Interesting.  So Standard.js is pretty cool because it just defines a more modern set of how JavaScript should look like, but I can't get over this, I'm sorry.
Yes, I've no idea.  I would love to know why this is.  Probably someone can explain it to me later on, but what I wanted to point out is that there are a set of languages and I think Go were not the first but they kind of have the strongest stance on this, like if you are writing Go and you are not using the official Go formatter, you are just doing it wrong.  Everyone else is using that, and so the Go community also doesn't have problems with figuring out how you should actually write Go code.  And there are a ton of other things and the last thing I want to point out is Elm.  Who loves Elm?  A few hands.  I like Elm.  I've never built anything spectacular in it, but I kind of like the approach and I also like the approach that it doesn't come with this huge baggage of I have to know what monads and endofunctors are before I can actually start writing functional code.  I like that approach, in the communication first of all, and elm-format does this weird thing, and with this I kind of would like you to marvel at the irony of an aesthetics presentation that begins and ends with comma first code, and I want to close with the reason that I wear this T-shirt is that I'm currently trying to build a greenkeeper that works for Ruby so if you are also writing Ruby code and not only writing JavaScript code, please come talk to me afterwards, and with that, thank you.  [Applause]