Source maps through the looking glass
Ben Vinegar

>> Hi everybody, hi.  Hope you are enjoying yourselves.  Get your bums inside, come on, let's get going with this.  Cool.  I hope everyone is loving it.  Is everybody pleased?  Come on, let's get up a gentle whoop if you are enjoying this.  Come on.  See!  There we go, very gentle.  Very gentle, hungover people.  It's okay.  Everything will be fine.  Take some aspirin, everything will be okay.
Our next speaker is joining us all the way from San Francisco because we haven't had enough Americans speaking here today.  They are here and taking over!  He works at a company called Sentry, he is a published author, wrote a book called Third Party JavaScript.  Hands up if you have read this one.  Wow, nobody has read it apparently.  We have an illiterate crowd here.  I hunted about Ben before and was going through his Twitter feed and was just looking at everything, and when you see heart, heart, favourite, retweet, retweet, you know you've found somebody very special, so without further ado, let's give a big hand for our next speaker, Ben Vinegar.  [Applause]
BEN: Hello, everybody.  So welcome to this talk.  It's called Source Maps Through the Looking Glass and I realise now that a looking glass is not actually a magnifying glass, it's a mirror, but humour me.  The idea of this talk is to do a deep dive into source maps, maybe use them today but they are kind of a black box technology so we are going to go deeper and uncover what's there.  My name is unfortunately Ben Vinegar, it's a real name.  I work at a company called Sentry, an open source company that informs you of errors in your applications, be they single page JavaScript applications or server side code or mobile apps and I will touch on that a little bit later in this talk.  So to kick things off, just want to talk a little bit about how JavaScript is used today in 2017.
How many people here use like a modern dialect of JavaScript, ES6, 2015, 2017, 2030, 2045?  Okay, so most people, then you are familiar with this slide which is a really simple function using ES6 modules and using like rest operator and it also has arrow functions.  I love these features, they make running JavaScript more fun but I work on a software product that still targets browsers like IE11 and I run it through a tool called Babel and it generates code like this and this will run IE11 just fine.  I want to keep going because for some contrived reason I must also wrap this in webpack, so I run that through this tool and it generates a lot more content, but of course I don't actually want to ship all of these characters to end users so I run this through one more time and I'm left with something like this, this probably seems pretty familiar for most people.
So somebody famous once said, like JavaScript has become the assembly language of the web, and I had heard this many times over the years and I always thought this was something that Brendan said, maybe it was when he announced Web Assembly, it seems like the type of thing that he would talk about but it was actually coined all the way back in 2011 by Scott Hanselman, an author and blogger, and he was just observing that when he browsed around his favourite websites, be they Google or Facebook, that the code that was being served to him, nobody wrote this; this was being generated by tools.  This was before Babel, webpack etc and the comparison to assembly is pretty apt.  It's not just a compilation target but assembly is really hard to read.  I do not know how many of you have worked with compiled languages or even written assembly but it looks like this, the actual machine instructions that your computer uses to do stuff.  Some of these commands are stuff like: move a value from one memory location to a register; do an additional operation on that register; jump to another location in your program, etc.  I have experimented with trying to debug compiled applications using just assembly and I have found this very difficult.  I have no idea what my program is doing whatsoever and maybe if you are a programming God you might be able to do this but I'm incapable.
Of course, you know, if you are debugging in the browser it doesn't look too dissimilar.  My code looks like this.  I have single letter variables, all my functions have been reduced to nonsense, stepping around - you can kind of maybe understand what your programme is doing but it's really difficult.  Similarly, this isn't just debugging in Chrome.  This is a screen shot from Sentry, and what we do is take crash reports from client side JavaScript and suck those up into our web server and give you a sack trace to help you reproduce the bug but it's not very experienced for minified code, if you are looking at column ... that's not very helpful.
If I compile a complication and add this like dash-dash debug symbol on Mac OS I get this decent folder on Mac OS if I'm building with LOVM - I don't want to get too deep into that - but if I fire up my debugger again with my compiled program and those symbol files are available, the experience of debugging is a lot easier.  Now I can actually step through the code that I wrote, I can actually inspect variables using their logical names and not using like memory addresses or register locations, and it's plausible to do things this way.
So debug symbols map machine instructions, just source locations and symbols, etc, so why don't we have this - if we've had this forever in compiled languages, why don't we have them in JavaScript or in other languages?  Well, JavaScript is different because we are not compiling into some intermediate form, be it by code or machine code; we are really just taking text and transforming it to some other piece of text, right, so the existing sort of debug symbol formats or whatever don't really work in this world.  Furthermore, when you have debug symbols and you are doing this, you are not sending it over the Internet back and forth, so many format symbols are not really designed for consumption over the web.  This is a bit of a long preamble to where we all know where this is going, which is source maps and what the topic of this talk is.
So if you didn't know source maps are pretty much a JSON file and it has a format whose content let you map file names, lines, columns that appear in sort of an output file back into - up to N input source files.  The source files can be any kind of text, there's nothing about the source map format specifically that's designed extremely for JavaScript.  It can be used for things like CSS ... or other transformations and it's also planned for over HTTP and we will see what that means in a bit.
So the very first version of this source map spec, I'm not sure exactly sure but I think it was dated around 2009 and was built for a tool called Closure Inspector.  Does anyone here use Closure Compiler?  Okay, maybe five hands.  I'm actually surprised, I thought there would be more than that but Closure Compiler is an optimiser and a minifier, kind of like prepack if you've looked at that a little bit, but it has been around for a long time and one of the Closure Compiler developers wanted to map what they were seeing back to the original code so he built a Firebug plugin and that used effectively the very first version of source maps.  It went through a couple of revisions and the latest version is actually revision 3 which was written in 2011.  Six years ago is a long time in our world.  It has been updated a few times.  But something to know is that this is just a proposal.  You can't go to MDN and find some really fleshed out specification that says what a source map is.  It's just like Google Doc that's on the Internet and you can see at any moment who is reading it at the same time, usually about a dozen people, and you can attempt to chat to them but they are usually not listening.
So despite the fact that this is kind of like this specification that doesn't have the standards value behind it, it doesn't really matter because everything kind of uses it which is really cool.  Compilers, you know, be it Battle or even C2 JavaScript compiler, module bundlers, every browser, tools like Sentry, so we unminify stack traces, Node stack support is interesting that will magically convert conceptions into their original format if you are maybe using typescript on the server or something like that.  So we are going to go through like an end to end example to understand how source maps work.  I am going to bring us all the way back to this function that I showed you at the beginning, add JS, just an add function etc.  I am going to run this through Babel, just to keep this simple, so from Babel I can just say: hey, take add.JS, take this file, I'm using this ES2015 pre-set to target a particular set of browsers, and then also specify this source maps configuration.  If I run that command a couple of things are going to happen.  My file is going to be modified a little bit, and also I get a source map file but before I jump to that source map file let's take a look at the output file and at dys.js.  It's pretty much the same except with one key addition which is it adds this line to the end of the file which is this source mapping URL directive.  This is the thing that tells browsers and other tools where to find the source map file that is associated with this JavaScript file.  So browser downloads your JavaScript file, goes to the very end, looks for the last comment and goes, "Aha, I need to add JS.map", and that is relative.  It doesn't have to be relative, you can specify a full path and that's where the browser will download it from.  A lot of people talk to me that they want to use source maps but don't want to expose  [audio problem] ... can have your source mapping URL point to a location that's maybe only accessible on a private network so you can download it and other interlopers can't.  You could even host those files locally on your own little web server, so you can point back at local host and you will be able to download that file.  Another thing that not everybody is aware of is you don't have to use this source mapping URL directive.  There's a header called source map that you can send down with your file that is a clue to your browser where to find these source maps, but not everybody has the power to just arbitrarily change headers.
Again, I mentioned CSS earlier.  It doesn't strictly have to be this // comment; you can also use this CSS comment at the end of your file too.
If you want to get started with source maps and just want to use them, this is pretty much all you need to do.  You use tools, generate a source map file, put them on your web server, the browser will download them and now when you start debugging you get to step 3.  That's pretty cool, that's it.  So I would recommend doing that.
Similarly, Sentry, we kind of act like a browser.  We actually when we see stack traces that have JavaScript files in them, will actually try to fetch those JavaScript files and if we see that there's a source map header or a source mapping URL directive we will download that source map and will apply it to your stack trace and try to show you the original file, the line and the column, and we even pull surrounding source code too, which is kind of cool, so in this case this is actually an example from our live application with some JSX and that's kind of neat.  But we are going to go a little bit deeper because I think it's interesting just to understand how does a source map even work.
How many people here have like tried to open a production source map in their text editor?  Okay, was that a good experience?  No, okay.  Typically this is what happens to me which is like my editor pretty much crashes, and they say because source maps can get really big.  It's totally normal for them to be megabytes in size.  We've seen source maps as large as 30 megabytes which is pretty absurd.  The reason we started this with a contrived simple example is that this entire source map can fit in one slide so this is what a source map looks like.  I've pushed around the white space a bit so you can read it easier and we will go through all the pieces of this really quickly.
So the very first piece is just a version spring, a clue to the browser what version am I dealing with.  As we learned early version 3 is pretty much the latest.  So pretty much everything says version 3.  What file is associated with this, what is this source map for?  In this case it's add.js.  It's associated with one file.  Sources are a list of input files that went into this output file.  In our case it's a single file, but if this had many components, modules, you can imagine this could be dozens, maybe even hundreds or a thousand files.  Sources content, this is like an optional feature of source maps.  Babel inlines all our code into the source map for convenience, and you don't have to do this but this is also what contributes to source as being so large but it's convenient because it works out of the box.  You don't have to deal with other problems like where do you find all of these other source files.
Lastly, this is the biggest part of what makes a source map a source map, which is this big mappings blob.  It kind of looks like a bunch of nonsense but it isn't and we are going to walk through actually translating something by hand, just so you understand what is taking place.
So one thing to know is that when you are doing source map parsers, they work through a source map or this mappings property linearly.  They start at the very beginning and the very beginning represents line 0.  It's not like random access, you can't go to the middle of this blob, you have to process the whole thing in order.  So each semicolon denotes a new line so we start at line zero and you will notice that this source map actually begins with five semicolons and that may seem kind of weird.  The reason for that is that Babel outputs some sort of preamble to the output file for which there's actually like no matching code or input file and the source map basically recognises that.  It's like: hey, just skip over this because there's nothing for us to even point to here.  So if we continue, we go past those first opening lines, and we get to what's called a segment.  Segments are comma separated and these are the things that actually make the translation from your output source to your input source.
Segments are made of variable length quantities.  Now, what is QA - maybe that's an L or an I, I'm not sure - GB.  So it's a variable length quantity called VOQ.  This is sort of a format that's designed for efficiently encoding arbitrarily large integers.  It's a little different and was designed for midi files which is interesting.  So for single characters this is fine, but as you get larger, 123 is only three characters, 123456789, five characters, or six, so if it's plain text and we've got to download it we want to represent that in as small a format as possible.  What is actually neat about VOQ is arbitrary lengths can also be included efficiently.  That's the last digit at the bottom.  It's represented by these five characters so we get to avoid commas and the negative prefix which is pretty cool.
The specifics of how to actually convert these, I don't really know.  I just let this library called VOQ which you can install to decode them and that's how I work through a lot of these problems.
So let's go back to this QAIGB.  If I decode this I get 80416 so what does that mean?  Once you break it down it's pretty simple.  This is where now the source map starts to make sense.  The very first value is the column in our output file, add.js, and remember because we are working linearly we already know what the line number is, which is like line 5.  The second value is indexing  [sound problem] array.  We only have a single array so it's 0.  Then the final are the input and the input source file, so if I convert this, this is basically what this segment is trying to tell us.  We are currently on column 5 line 9 of add.js.  For this one it's column 5, line 17 and if I break this down and go back to my input and output file, it's saying in the output file add is over here and in my input file add is over there.  That's pretty much how this works.  
Source maps really just - they could be character by character, there's nothing that would stop you from doing this but we only need to source map the start locations of identifiers.  That's efficient because if we mapped every single character this mappings property would be gigantic but if we only have to do identifiers, it's much smaller so I am only going to convert one more value just to kind of bring this idea home.
The very next value, the very next segment if you can see it is actually just a capital G which is a little confusing because it's like: wait a minute, didn't I need four values to translate something?  What am I going to do with this single value which is actually a 8?  Oh, actually I think it's a 3.  I may have messed this up.  So segment values are relative.  This is sort of like a space-saving kind of idea, right, like I don't need to have the absolute value for every single segment.  I can just work off what I was doing in the last segment so if we just add this value to the previous segment and we get a new location which is 11 instead of character 8 - bear with me, this is a little confusing - but the idea is there was another identifier add.  Add appears twice, right?  So this is actually linking back to the same location.  Remember, the very first value is the location in the output file, right, so line 5, line 17, like that didn't change.  So what's really happening here is that the source map is telling us that this add function appears twice in the file, which is kind of interesting.
So hopefully you have a basic understanding of how this is going.  I would just keep working through these values, keep translating them, keep getting new translations, but the idea here is that I finish in a place where I basically take all these values and I dump them into some data structure like a table so that going forward I don't actually look at the source map; I just kind of like query this table for the data.  This is how Web Inspector works, other tools, Sentry etc, work.  They just munch through a source map, generate this big lookup table and then the rest is - just kind of works by itself.  It seems like a lot to take in but the good news is you don't ever really need to know the particulars of how this works.  I just wanted to explain what is happening because it's kind of neat.  There is a tool called source-map, it's on npm, it's from Mozilla, and it does what we just did, breaks down the source map and provides an API where you can look up the location for yourself.  The API is a little complex because it does a lot but it looks like this.  I import this library, I read my source map file from the file system, I then create what's called a source map consumer, and then I can look up, you know, original position for line 6, column 0, whatever I want to look up and it will tell me which file, what line, what column, so if you are working with source maps and you've ever struggled with - it seems like the lines and columns don't match up exactly the way that you wanted, I recommend using this library to look up the values yourself to see if they make sense.  That can spare a lot of time with debugging.
So this kind of takes me to the end.  What do we learn?  It's a bit of a wrap-up.  So source maps are kind of debug symbols for the web.  That's close enough.  They are just files, lines and columns.  They are designed for efficient transmission over HTTP, that's why there's these relative segments, etc, and the cool thing is that almost everything supports them today so if you are not using them, you should be using them.  So again, my name is Ben Vinegar, I hope that you've found this talk vaguely illuminating.  If you want to find me, this is me on the Internet.  This is a link to pretty much everything we talked to today.  Please check out Sentry, it's really helpful and it's open source and you can run it on your own server.  Thank you.  [Applause]
>> Thank you so, so much to Ben for that.  