Two Problems:  Regular Expressions for Revolutionaries
Sarah Saltrick Meyer

Live captioning by White Coat Captioning
REMY: Okay, folks.  We've got some people coming in, so next up we've got Sarah talking about regex.  I feel like it is superb to get absolutely lost for days, so I'm looking forward to hearing more about this talk and I'm going to give you 15 seconds to sit down, run to your seats and clap.
SARAH: We can have a little banter while everyone takes their seats.  How is everyone doing?  Everyone is having a good JSConf?  Nice.
REMY: Please welcome Sarah.  [Applause]
SARAH: Hi guys, thank you so much for the warm welcome.  JSConf really is a conference among conferences and it's really a pleasure to be here.  So the name of this talk is: Two Problems.  It is in fact to talk about regular expressions, if regular expressions are something that scare you please take a seat and sit down, this talk is for you.  If regular expressions are something you love and feel very comfortable with, also this talk is for you.  So who am I?  My name is Sarah Saltrick Meyer and I'm a web developer based out of New York and I work for a company called Buzz feed again doing web dev.  So there's a real classic and wonderful joke about web expressions.  Some people when confronted with a problem think: I know, I will use regular expressions.  Now they have two problems.  You may have heard this joke from the person sitting next to you at your first job, that's certainly when I first heard it, but the actual source of the quote is a guy named Jamie Zawinski on a group in 1997 and Jamie was an Emacs devotee, approaching the status of a religion for him apparently, and he hated Perl with a passion.  One of his other really meaty quotes is: Perl combines the power of C with the readability of PostScript.  So clearly a man of strong opinions and pithy statements.
Why would he say this?  Regular expressions are a great tool, aren't they?  You can use them in a HTML input box to validate the form of input.  Obviously you use them all the time when you are trying to match an pattern in text.  I've seen websites ... but why would regular expressions be a problem?  I rather think it's because of things like this.  Can you all actually read this here?  Use your hand if you can read it.  Okay, okay, so does anyone recognise this nasty scrum of characters and numbers?  US phone number, thank you!  And wow, it's just gross, isn't it?  It's just nasty, looks like something you would pick off the bottom of your shoe programming-wise, and so the reason I think that people - regular expressions are a problem even as they solve problems for us is this lack of comprehensibility.  When I need a regular expression at work, I Google it, so I would just Google regular expression for a phone number and take that top Stack Overflow answer and probably most people would do the same, but regular expressions are something more than just something that we, you know, can take somebody else's advice for.  They are more than something where you find the experienced senior dev in the room, or maybe the one person who you know is a regex whizz and you go ask them for it.  They can also be something like this.  So I totally stole this beautiful graph from JavaScript  [inaudible], a classic, and this is a description of the various ways that white space can be evaluated that code can sort of not be evaluated within JavaScript, and let's run through them  [sound problem] ... here.  Obviously a space will just be a space.  A tab will just be evaluated as a tab, and a line end similarly, nothing will happen.  But then we get down into here, so if the parser is running and hits a forward slash, well then, if it sees another forward slash and then it sees any character except for a line end, and it can seen any numbers, so what is that?  Of course, it's a comment, yes.  Then it gets a little bit more complicated, of course, for our beautiful multiline comment.  We have the forward slash, we have an asterisk, ooh, and then I can optionally - you see it's not on the path here - I can optionally have another forward slash but then I have to have any character except the slash and the asterisk, and I can have as many of those as I want.  But I have to finish off with another asterisk before my final forward slash, and the real meaning of this diagram here is that you cannot - you can have slashes and asterisks within your comment but if you have a slash and then an asterisk, you've closed the comment.  And you are done.
So, gosh, well what does this have to do with regular expressions?  This is a regular expression I wrote for you guys very specially.  It really broke my brain, it felt like a test in school because I did actually used to do this at school, I would have a regular diagram like that and have to turn it into a regular expression, not with Perl syntax though, this is Perl syntax which of course is also used in JavaScript.  Without going into it too much, we have the simple cases, we have a space here, a tab, ooh and then it starts to get clicked.  We have these escaped slashes and then line ends, and then this incredibly nasty thing is the - you can have asterisks and slashes but they can't be next to each other unless you are closing out.  So, what exactly is a regular expression, my gosh?  They were defined in the 1950s before there was such a thing as an automatic computer really.  So they pre-date the actual machines that we could our work on and they were defined by a wonderful guy named Stephen Culchrane who you love even if you don't know who he is because he is responsible for this little star, the clean star, which you probably use all the time.  The clean star is not part of regular expressions per se; it's rather, I would say, a notation that we very frequently use in regular expressions and probably the most commonly used of all pattern matchers is: tick everything, star.  Yes, I love this very much.  I think it's very pretty and also useful.
So what exactly makes a regular expression?  It's a set of characters that describe other characters with origins in the attempt to describe natural language in a computable way.  So we have that pipe.  We have the concept of grouping, the notion that if I have ABCD, or AXYD then that is equivalent to ABC or XYD; and then lastly, quantification.  This syntax may be familiar to you, the question mark is I believe 01, the star is of course 0 pipe, and the plus is 11 or more.  So we've got all that.  We kind of know what we are talking about here, but let's try to place regular expressions in sort of a wider world of concepts, a wider world of attempts to describe language, and actually we think of ourselves as web developers, we do code, but code is language and it is specifically an attempt to translate human language into language that computers can understand, and regular expressions are just one in a whole set of toolboxes for doing this, and they were described by this gentleman, who may be familiar to you, this is Noam Chomsky, who in addition to his wonderful political opinions also is responsible for the Chomsky Hierarchy of Grammars so as you can see regular expressions are down here, the most limited subset of the Noam Chomsky hierarchy and then we work air way up through the context free and others, so what are these?  Actually the type zero unrestricted grammar is something that you are also all familiar with and I say I am familiar with these machines in the same way as regular expressions - I'm certainly not an expert, I just know they help me do the things I need to do.  What exactly is a Turing machine?  This is a Turing machine that somebody built with Lego.  It has wheels and goes back and forth.  We have a beautiful quote which I am going to read out: a Turing machine is an unlimited memory capacity obtained in the form of an infinite tape marked out onto squares on each of which a symbol could be printed.  At any moment there is one symbol in the machine, it is called the scan symbol.  The machine can alter the scan symbol and its behaviour is in part determined by that symbol but the symbols on the tape elsewhere do not affect the behaviour of the machine.  However, the tape can be moved back and forth, this being one of the elementary operations of the machine.  Any symbol on the tape may therefore eventually have an innings.  That is a quote from Alan Turing, I think in addition to being a brilliant computer scientist and truly the father of the industry that we work in now, he was a lovely writer as well.
So Alan Turing, of course, committed suicide after he began to be persecuted by the British Government for being gay, and I think there's a lot of irony in the fact that a man who contributed so much to our understanding of patterns and communication literally died for not fitting a pattern that was prescribed by the society that he lived in.
Well, moving right along, type 1 grammars, they are boring.  I don't really understand what the use case is for them.  It seems to be mostly theoretical.  But they are called context-sensitive because they come with a little bit of context.  So I don't know them, I don't know her.
The type 2 grammars on the other hand, I'm not going to read out all this math, it comes from Wikipedia, I do encourage you to look this up, but most programming languages are interpreted by computers as type 2 languages so as we are moving up this hierarchy here.  And type 2 has something extremely important, type 2 languages have a stack.  So you will note that in a regular - of course, in a regular expression there's no concept of memory.  You are only - you don't know, as you are matching that pattern, the things that you've seen before but once you have the introduction of a stack you can keep track of the past and use it to help you evaluate the current input.
Then type 3 grammars are irregular expressions and they are equivalent to finite-state automata which is something else you may have used, perhaps a finite-state machine library for some context at work so regular expressions are mathematically equivalent, they can always be translated in between each other, and this is a picture from my native city.  These are some turnstiles at a subway stop in Harlem and subway turnstiles are actually one of the classic examples of a finite-state machine, and I will show you how.  So the way that a turnstile used to work, now pretend that the coin is a Metro card swipe, these coins are obsolete unfortunately, if the machine is locked then no matter how much you push, nothing will happen.  You return to the locked state.  But if you put in a coin, then you are in the unlocked state and no matter how many coins you put in, it will still be unlocked, you have done nothing to it.  I have actually done this, swiped my Metro card accidentally multiple times, spending $275 each time, very frustrating, but then if you push through the turnstile, you return to that locked state and you can only get out of it again by putting in a coin.  So you could actually write a regular expression for this where you represent where the coin and push would be your letters, your characters in it, and the locked and unlocked states would be the potential states that you could get to.
So one thing that you may have heard, it's another thing that I heard sort of second hand at my first job, is that you can't parse HTML with a regular expression and the reason for that is the same thing that I said about the context free grammars, they have a stack, right?  So to parse HTML we need that stack.  We need to put down the HTML tag and then we need to put down the body tag and then we need to put down our headers and build up that stack and as we unparse or get to the end of the execution, we start popping those elements, author stack as we see their closing tags, and that's how we get proper HTML parsing, so that again because regular expressions do not have a stack, do not have a sense of memory, cannot be done with a true regular expression.  But the regular expressions that you use in programming languages like JavaScript which takes its implementation from Perl, and Perl I think has been the most significant influence on the development of regular expressions in sort of day-to-day programming - you know, I personally, one of the very first things I ever had to do that somebody paid me to write code for was to write Perl scripts to parse some documents and put them into a different directory structure.  It's a good task for an intern actually.  You learn a lot.  So Perl expressions have features, those negative look-aheads that make them no longer pure regular expressions but capable of a wider variety of tasks than true regular expressions are.  So from that I have a quote from Larry Wall who did create Perl so probably the worst enemy of that Jamie guy I quoted earlier.  "The term has grown with the capabilities of our pattern-matching engines, so I am not going to fight linguistic necessity here."   A wise man.  "I will, however, call them regexes ..." so what's the difference really?  Those regular expressions meet the criteria, the deterministic criteria in particular it's important to remember, that each of its transitions is uniquely determined by its source state and input symbol and reading an input symbol is important for each transition; with the power of modern regexes, has actually become quite divorced from the underpinning of the regular concept, lovely as those are.
So again a regex has only its state and a Turing machine has memory, and regexes therefore are appropriate for a sort of service level parsing of information.  They are very useful and they help us a lot.  They still are only one tool for us and as with many things, as with many things in programming, right, a limit is not necessarily bad.  If you were using a limited set of tools, you may see better performance because there is less that it has to do, whereas so regexes exist then in a very limited world that is connected to a much broader world of computation and of the attempt to let computers understand humans, so there's a sort of a sad ending to a lot of the attempts to describe human language that many like Turing and Chomsky were working on, and this was sort of the post-war attempt to turn human language into a set of rules that machines could understand easily and the notion that we would be able to find a theoretical description of all human language.  I think as programmers you all know better than anyone else that we are never going to achieve that, right?  We are probably never going to write a programme that deterministically understands human input.  This is actually, the rise of machine learning and non-deterministic algorithms to parse language is a recognition of the notion that we don't have - we will never find a true answer, a correct answer; we can only throw a bunch of guesses at the wall and determine which one is closest to our understanding as humans.
So I will leave you with - there wasn't that much JavaScript in this talk, right?  So it's right here.  This is about the implementation of other expressions than JavaScript.  Of course you may declare a regular expression in one of two ways, either with those lovely backslashes or with the regex constructure so the previous one is for a value that will never change whereas if you want to construct a regex dynamically and have it evaluated, please use the constructor and enjoy writing regular expressions in JavaScript.  I certainly do.
So here I have been thinking a lot about regular expressions since making this talk.  I sort of have a vision of applications as being modelled like that turnstile, of designers making automata ... and then somehow turning that into regular expression.  I don't know how that would look but it's really cool.  They are also really good with games, so write that with a regular expression.  I think you could also make some cool web art  [sound problem] ... obviously writing a chatbot that's too obvious for words, but a lot of us, because we are web developers and eager to take any tool that works, we - if we don't know about the theoretical underpinnings of this they can remain very opaque and difficult to understand.  I have a math background and still look at the Wikipedia definition of these things and, oh, it breaks my brain, but knowledge and education is a treasure and knowing how things work, even if it's not going to help you in your day-to-day is, I think, something that is very beautiful and very useful, and it will enrich your understanding of what you do on a day-to-day basis.  So seek out theory, and also don't blame other people for not having knowledge of theory.  Get as much as you can and give as much to other people, and I think that's the way to be a truly effective programmer.  Thank you very much.  [Applause]