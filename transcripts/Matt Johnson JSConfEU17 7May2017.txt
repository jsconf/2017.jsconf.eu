The Past, Present and Future of JavaScript Date and Time APIs
Matt Johnson

Live captioning by White Coat Captioning
>> Wow, that was fantastic.  Are we going?  I will just go with the microphone.  It will be fine.  We will come back to this.  Microphone, hey, there we go.  Fantastic, thank you.  Hope everyone has been enjoying everything, hope you've all found the fantastic things that are outside, we've got all the ice cream trucks out there, the frozen yoghurt truck.  I'm saying yoghurt like an American now, it's okay, don't worry.  Are we all good?  Come in.
Fantastic.  Right, our next speaker is the maintainer of Moment.js.  I think you might know him from all the questions and answers he does on dates and time and things like that in JavaScript.  He has come all the way over from Seattle, so please give a very, very warm welcome to Matt Johnson.  [Applause]
MATT: Just a second here.  Okay.  So everybody hear me all right?  I'm Matt, I work on Moment.js.  Everybody in the room use Moment.js?  A few people, yes?  Lots of people, pretty much everybody.  We have been lucky enough to become one of the premier libraries for JavaScript.  We didn't set out to do that.  It would have been nice if JavaScript date was good from the beginning so that's kind of what I want to talk to you about today, how did we get here, what can you do today, are there other good options other than Moment.js, I think there are, and what are we going to do in the future?  So I work at Microsoft, a site reliability engineer which means I don't do a lot of JavaScript in the daytime.  I have been a JavaScript developer for quite had a while though, also a .NET developer.  I mainly focus on the domain of date and time so if you ever have questions about time zone, daylight saving time, how to schedule things, any of those sorts of topics, you can probably find me on Stack Overflow, that's usually where I hang out.  I also have a lot of open source daytime related libraries and if you've got daytime bugs on your projects I may have jumped in and fixed it.  That's what I do.  And I like cheese, because everybody likes cheese.
So what is a date, let's talk about dates.  I think a date looks like this January 1st.  Everybody agree with me that's a date?  Yes, I think that's a date.  But that gets us into problems with JavaScript.  If we take a look at this little demo that I made here, this is literally all I have, a HTML5 date input type, okay, and all I am going to do with that is just give you the output.  I am going to feed that into the value of an object and I am going to say to date string.  Let's say I was born today, okay, what happened here?  I picked May 7th but I got May 6th.  Does anybody ever run into this problem with the date object?  This is one of the things that people yell and scream about the date object.  What's going on here?  What's going on here is that I'm from the United States and I haven't adjusted this computer's time zone to be east of the UTC line, it's still west of it, so if you happen to be that negative offset from UTC you will find that JavaScript will throw your dates off by one, and this happens because the specification originally wasn't clear about what to do when you only have a date.  It just said: if I've got some value what I don't know the offset then the offset must be UTC.  Well, what's an UTC day?  From UTC midnight to UTC the end of midnight - the only people that I know of that are always on an UTC day are mostly in Iceland.  Iceland is on GMT year round.  Even in Greenwich where they draw the Greenwich mean line, that's not on UTC all the time.  They are UTC plus one right now for British Summer Time so there's a discrepancy in the last two forms here between this specification which is where we get all of our date and time standards from and the other specification.  As you can see the third item on there is a date and a time and originally it was said that should be UTC but they later corrected it to be local so fortunately for date and times we now know all modern browsers will be on local time but for date forms they got stuck with UTC and really this comes down to web reality.  We wanted to change it, the implementers all wanted to change it but when Chrome tried there were so many lash backs within a small window that they had to revert so the script now only says four date only forms they are UTC and that's because that's the reality of the web since the early days of the Internet.
But a date - what is a date?  It's not  [audio problem] in JavaScript it's not, it's a time stamp.  It's the number of seconds since - the number of milliseconds since - you can't have.  We lost display here.  Hold on.  There we go, so we can't have just the date represented in terms of milliseconds.  You all should probably know this but not every day is a whole number of 24 hours exactly and the days that aren't are random all around the world because of time zones.  When we are in standard time and then we switch to summertime or we call it daylight time in some parts of the world, we might have a 23 or 25-hour local day depending on which way we are transitioning.
If you live on this small island called Lord Howe Island they only switch by half an hour so you will have a 23.5-hour day, or a 24.5-hour day, so you can't just measure a date in terms of milliseconds.  It's the wrong type.  I like to call it a datish.  We have the falsey, truthy, it's a datish.  There's this wonderful quote: off by one and naming thins, cash validation doesn't apply here.  I usually throw time zones into the mix of things that are hard in computer science so one wonders what were they thinking, why did they do this?  I have to go back to this, Brendan and I, one of the inventors of JavaScript called Live Script back then, they had very little time to do this and they were told just make it look like Java, and he has told us many times, and there's a couple of blog posts.  Actually it was Ken Smith, not Brendan, Ken of net scape, took the utility code from Java in the implementation and translated into the implementation for the early days to JavaScript.
This is what that looked like.  Everybody thinks that it all happened all at once but if you look at the dates you can see that when they developed it Java was in beta.  Nobody had used this thing.  They just said this is how Java does dates so this is how JavaScript will do dates and by the time Java 1.0 came out the JavaScript prototype was set in stone and then when Java 1.1 came out we deprecated almost all the functionality, moving it off to something called Java calendar so we are stuck with a model that was fundamentally broken and found pretty early on, and we never did anything about.  We published ECMAScript 1.0 afterwards and adjusted that and that's just what we have today, so there's a lot of things that are wrong besides just the date parsing.  I showed you how when you parse the date you can be off by one but look at this code.  Can anybody guess what this result?  This looks reasonable.  A lot of people would write something like this.  Just think in your mind what you might think it is.  I look at that and say: well, it's December 31st and I'm adding a month so it must be January 31st, is the result.
>>  [off mic]
MATT: We end up at March 2nd.  Only when I run this code from this time zone in Berlin.  Notice in terms of time we did something implicit which converted it from local to UTC time and gave me an UTC-based time stamp so not only do I end up on March 2nd, because I actually started on November 31st, which doesn't exist, so I started - sorry, on January 31st.  So I went to February 31st, which doesn't exist, so I went into March, and then I went back an hour for UTC.  So there's a lot of things wrong with this.  The other thing that it highlights is that data is mutable.  Notice how I've added a month?  I had on get the month and then increment it and then rely on this bubbling functionality in order to move from one month to the next.  These are really difficult concepts, especially for a beginner developer.  Date in almost any other language is a value type, it's immutable.  It doesn't change once you create it.  If you add a month, you have a specific method; add a month and you get back the one with the month added.  The other thing we have wrong with date is notice nowhere here did I say what time I was starting, I just started it in local time so the only thing it supports is the local time that the environment is running on and UTC.  Well, that's really bad if you are a Node developer because nobody cares about the times going on your server.  You really shouldn't care about times going on your server anyway.
Okay, this one I love, strings should be interchangeable in most JavaScript things, we have string 0, regular 0, 00, or 000.  Does anybody think this should give the same results, whatever they might be?  They kind of should be the same defaults.  I will give you a hint, they are in descending order here.  Every one of those things is going to give you something different, and so the first one is because when you only parse a number as a string it's treated as a year, so year 2000, and anything that is parsed as a number is treated as a time stamp so we are right at the epoch there.  Notice it's not midnight there, it's 11.00am so not even the same time.  1.00am.
1900 is because if you pass a year from 0 to 99 JavaScript data treats that as 1900 to avoid Y2K problems but as soon as you go to 100 that is year 100 so they are not even sequential in terms of parameters.  And 09 just because of the overflow situation I showed you before, we have no such thing as the easier day of the month so it just goes back one day.
What do we do with this?  We saw Java came out with Joda-Time.  If you are a Java developer you should be familiar with it.  It is the base for 3010 which made its way onto Java 8 so you should be using Java 8 with the time package with a few tweaks to make it better.
There is alternate one that is also very good called Time4J and they take a little different philosophy between the two.  We also had to address this with libraries.  Really early on there was a date JS library and I don't recommend you use that today but Sugar and Moment came on the scene in 2011 and Sugar is still pretty good if you want to do something called natural language parsing, like if you have a string that says: what time is it three days and two months from now and it's actually spelt out as a string, Sugar will parse that and try to make a good guess at it.  But most people are using Moment.  Moment does about 90% of the things you would want to do with date and time.  Maybe even 99%.  But Moment isn't the only thing out there.  There are people working on a port of the Joda-Time standard into JavaScript, that's the js-joda library and I think JS is pretty awesome.  There is also this thing called date functions which has got a lot of notoriety lately, which says instead of a very large JavaScript object if all you need to do is add a month, let's just add a month.  So you pull in individual functions for different things, so I am going to show you those libraries.
Moment I saw everybody is familiar with.  We are very specific when we do our parsing.  We don't make that assumption that said: I can tell you what you want.  No, I can't always tell what you want, sometimes you have to tell me so if you give me a string with no context and you don't tell me what it is then I will assume it's local time because that's what the date object does.  If you give me a string with no context and tell me you want it as UTC then I will assume it is UTC and we have time zone support through the Moment time grown library that imports the database that pretty much all modern computing uses.
Moment's API is fluid and intentional so we can do something liked and 200 days and then format that.  I can tell exactly what my input style should be so there's no confusion on whether that's July 5th or May 7th, because I'm telling you explicitly that it's day, month, year format.
The only problem that we have lately with Moment is it is still a mutable API and that's because when it was originally developed it was built using the JavaScript date object as its basis so notice I clone the Moment here before I start adding to it.  If I didn't do that, it wouldn't just output the same string here but would also change the value of this M variable, so it's important when you are working with Moment that you realise it does mutate the object as you work through its API.  That's something we are considering from OF3O.  There's some progress on that so hopeful we will have a Moment 30 with immutable API.  You can validate simple dates.  It does what it says it does and it does it pretty good.
Let's look at this date functions library I mentioned.  It's very lightweight and modular, and the intent is every single function is its own module so you only pull on the ones you need.  If all I need is something that will format a string and add some days then I just import those to functions.  It uses date objects as I was saying so I create a date object, I format it, I get the output.  Again, remember that JavaScript date object has zero base months so it looks like I'm parsing January 1st but it is not, it is February 1st so the string says February 1st.  This adds days as it says, so it doesn't add a value.  So if you want immutable functions check out date functions.
Js-joda is also really good, it also has an immutable API, it models separation of concerns very well so we have a different object which is a local date and local in this context doesn't mean local to the computer; it means not - it means could be local anywhere.  It means somebody is local.  And that's just terminology that has been borrowed over from the ISO8601 standard into Java and now up into js-joda so you may see that a few places.  When we work with this API, we don't have to have the API guess what we want; we tell it specifically what we want.  We say: here is a date, get the start of the day, I wants that for Berlin and then I want to know the equivalent time in the computer's local time or in UTC.  I can do these things very easily.  The start of day function is a really interesting concept also.  Keep in mind that not every day starts right at midnight so a start of day isn't just snap to midnight and truncate off data.  If you are in Brazil or a few other places around the world when they start daylight saving time they go from 11.5959 of the night before up to 0100, so you have to have those rules in your data to know that the start of day is not necessarily midnight.
And Joda-Time is also immutable, so we have D1 and D2 here being different objects, the same as I showed you before.
So what are we going to do?  How are we going to get out of this mess where we don't have to use libraries or deal with an API that is broken.  I think we should fix it, do you think we should fix it?
So Moment.js is a JavaScript Foundation member, Maddie and Brian Terlson are helping with this and we've reached stage 1 which means we have general approval of the committee to think about how to do a new date API.  We have a general idea about what we want but it is not locked in so definitely come take a look and give your opinions, we will take issues on GitHub, we will take poll requests, any way you want to talk to us or come find Maggie after the talk here.  Generally we want to make date better.  We want to learn from the APIs that have come before us, not just in JavaScript but in other languages, we want to be comfortable for everybody who uses JavaScript so it needs to be idiomatic, not to bring in a whole load of Java cruft and other things that don't apply, at least not today, and we are going to do the 1 base months, not the 0 base months.  I will put my foot down on that one.
Possible ideas: it might look like Moment, or Joda-Time or Time4J, it might be that we provide functionality so that platforms can do what they need to do in a smaller and more direct way but we don't know yet, so help us figure it out.
Here are some examples, and you can see we have this zone date time object that's a very joda-like object but I'm not doing a lot of object construction to get the time zone.  I'm just parsing them along as strings.  If I want to add time, I might do something like add to, and that's very Moment-like.
What else might we be able to do?  This is actually a very complex problem if you are in a scheduling environment.  If I need to run an event at the same time every day but it's in the user's local day, so this is a starting point and then I say I want the next four occurrences but I'm crossing a daylight saving time transition so 8.00am every day even when the offset in the Pacific time zone changes from minus 8 to minus 7 you can see here the UTC output has changed also so I cannot schedule in UTC time, I need to schedule in local time and doing that without a library is really, really hard with the JavaScript object.  Most people will just say: plus 24, times 60, times 60, times whatever to get the next instant but then you will find you're running at 7.00 or 9.00am and they will be off by one.  It would look something like this.  If you think this looks awful and you have a better idea, come talk to us.  If you think this is great, let us know, and that's really all I've got so please give your feedback.  If you have other questions, come find me afterwards, or you can always post on Stack Overflow.  If you just tag it with date time or time zone, I will find it probably.  Lots of other people as well, and I have a six-hour course on fundamentals on Pluralsight if you really want on dive in, so thank you very much.  [Applause]
>> Thank you so much for that.  That was fantastic.  We are running a little ahead of time so I think maybe we've got time for a question or two, if you want to handle that?  Anyone has any questions, stick your hand up.
MATT: Question?
>> Questions from anybody?
MATT: No.  Okay.
>> Thank you so much, I honestly learned so, so much from that.