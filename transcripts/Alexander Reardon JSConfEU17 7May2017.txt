Let's Go Big
Alexander Reardon

Live captioning by White Coat Captioning
>> Hi, everybody.  I hope you are all caffeinated up and you've all got the shakes, the nerves now, you should be very excited because our next speaker is absolutely fantastic.  He has flown all the way from Sydney, Australia, where he works at Atlassian, and he has come to tell us how to free numbers from their constraints, so if you will give a very big round of applause for Alexander Reardon.
ALEXANDER: Hello, yes.  Yes, as mentioned I am going to be talking to you all about big numbers, so these are numbers that are bigger than what we can naturally do in JavaScript by default.  That's my Twitter handle there if you want to find me.  I was pretty late to the party in terms of Twitter so the last letter of my first name and last name are collapsed but you can find me there.  Just a bit of a warning.  There will be some math in this talk.  It's kind of hard to talk about big numbers without talking about math but I will try to keep it as easy and light as I can.
So firstly, numbers.  What are their characteristics?  What are the defining features about numbers?  So firstly we want to be able to store some value that then we want to retrieve at some later point, potentially print it out on an user interface, but really the unique and defining characteristic of numbers is the ability to do operations on those numbers, these pre-defined mathematical things, so things like addition, subtraction, multiplication and division.  Now, JavaScript only has one number type and's a 64 bit, and this isn't unique to JavaScript, you will find it in other languages like Ruby and Python.
So let's look deeper.  64 bits, this is the first bit we use to control the signs, positive or negative.  The next 11 bits, I like to think of them as the scale, so this is how big or small the number is and then the last 52 bits control the actual value of the number.  Now, I've got 52 bits written there because it sort of has 53 bits in that it assumes 53 but the first bit is always 1 so we can store 53 bits of information there but we only have 52 bits and this number system is very similar to scientific notation.  So you have a value, in this case 8.12, and times by some scale to give us our result, and this is exactly how floating point numbers work as well.  Now, I mentioned we have 53 bits and it's no coincidence that the maximum value we can store inside these numbers, this is what happens when we set all of those in the value components to 1, we get 2 to the 53 minus 1.  That's our maximum value that we could store and if you have seen that number around but you didn't know where it came from, it's number dot max safe integer, is what it is.
We get this huge number here known as number dot max value but it's kind of a bit useless for what we want to do in that if you have a number, say in this case this, and you add one, you get what you expect but if you add one again you get something you didn't expect, it doesn't do anything and you get all this weirdness.
For our purposes we are going to say because the defining characteristic of numbers was these operations we really don't want to be going above that number or we will have unexpected consequences so that's where JavaScript is.  Now, let's think about how we could go bigger, how we could push numbers to both store numbers much bigger than max safe integer and do operations on them.  You might ask why would I be interested or care about big numbers?  There are valid and practical uses for big numbers, say if you are dealing with big distances, say astronomical units, or you are doing any accumulation of big historical data so say counting the number of characters in tweets over a period of years you might start to run into these problems as you keep piling counts on counts.  Another common use case is if you are shifting decimals, so say you have a decimal value you want to shift to become an integer value, you might hit these problems.  But really it's a bit of fun.  It's to see how far we could push this idea, overcome this limitation of 64 bit floating numbers and it's also a bit of a challenge for us as well and hopefully we will learn a lot by trying to overcome these barriers.  There's a lot of different ways of doing big numbers.  I will link this on Twitter afterwards, but it has a few other ways of doing them, and hopefully after this talk you will see that there are probably lots of different ways that I didn't even explore about doing big numbers so let's get into it.
This is my first technique and probably the most basic but very interesting, and that's converting numbers into strings, so say we have the number 125, we simply convert it to the string 125.
This is really easy, we take a number and convert it to the string, this is the format of that system and by doing this simple trick how big can we go?  So say we have three slots the biggest number we can store in three slots is 999 and in a more general sense if we had n slots we could store 10 to the n minus 1.  Which raises a question: how long is a string?  How big can these things be?  The answer today is pretty vague.  It's not locked down in any spec anywhere.  But if you test in browsers and Node you will find this is a safe power to use, to the power of 27.  That's safe and consistent so that's what we will use today. it will be this but today we will be using to the power of 27.
So what does that even mean, how big have we gone?  I've come up with this analogy which I will use for the rest of the talk as well.  So say we had a sheet of paper and on that sheet of paper we start writing numbers so on the first line we write 1, then 1,000 on the next line, a million on the line after that, a billion, and so on.  And each line is a centimetre big.  The thing to note is that each centimetre is a thousand times bigger in value than the centimetre before it.  So with JavaScript numbers we can get 6cm down this page until we hit that max safe integer.
If we use this string method it would take 474km worth of paper to store this number which is staggering when you consider that each centimetre is a thousand times bigger in value than the centimetre before it so this is a really simple technique and we've completely blown away that max value that we had before.  So it's from here to Berlin and back twice, with each centimetre being bigger than the one before it.  This is a table I am going to keep referring to as we go to record our progress, so simply switching to decimal strings we have a huge increase in scale.
You might think that's great but really what we care about with numbers is the ability to do operations.  I think the screen has gone.
Here we go, so say we wanted to do addition, with two strings, so we have a string, 256 and 182, how do we even begin to start doing addition with these numbers?  Well, we could look at the first column on the right.  We want to add 6 and 2 and we could create some system where the character 6 plus the character 2 yields the character 8 and not do any math but because these are small integer values we could lean on JavaScript numbers under the hood to do these small, safe operations so we will do that for convenience.  So we have 6 and 2 and get 8.  Move to the left and we have 5 plus 8 which gives us 13.  We have a problem because we can't store 13 in one column so we do primary school mathematics where we can subtract 10, carry 1 and  [audio problem] ... and carry that number to the next column, we have one, plus, two, plus one, which gives us 4.  We are able to add these strings which is pretty fun.
What's interesting is that was a really nice algorithm, looking at two numbers at the time and constantly shifting down the number.  Let's take a look at subtraction.  This one is a little bit harder so say we have 4,005 and want to subtract 11 from it.  So 5 minus 1 gives us 4, then zero minus 1, we can't really do that so we start with a lookup phase so we start looking down the number until we find something that we can borrow something from.  So we found 4, we take one from that, we can carry a 10 back.  Now we can take something interest that so that becomes a 9 and we can carry 1 over and now we can do something, we can take 1 from 10 which gives us 9.  Then shifting down again we have 9 minus 0 which gives us 9 and 3 minus 0 which gives us 3.  Okay, we've got our answer.  But that was kind of gross, right?  We had to start shifting down, then did this search, then come back, and then search again and if these were really big numbers this could be extremely inefficient.  You might be searching back and forth, back and forth a lot.  So this is much different to what we had with addition where we were simply moving down two digits at a time.  So that's just something to keep in your mind that that's a pain point for this system.
Now let's look at multiplication.  Bear with me.  There is not too much heavy math more to go.  So multiplication: we could write a multiplication algorithm but really once you have addition you can deduce multiplication for free.  So you had 0, we add 10, we add 10, we are done, you have an answer.  We could just leverage that addition function we already had.  Admittedly it's not super-performant but you have the idea.  Addition.  Same idea except now we are going to keep subtracting from this number until we can't subtract anymore.  We start with number 6, subtract 2, subtract 2, subtract 2, we can't subtract anymore, but we can count the number of times we subtract and so the answer is 3.  By having addition and subtraction we were able to get division and multiplication for free which is great.  So as soon as we create a system with addition and subtraction we can create one that has division and multiplication as well.  So we did pretty well.  We created a system which has a huge number value as well as being able to do this pre-confined mathematical operation, and we built this system - again I will tweet this link at the end - if you are interested you can have an play with it and it works for decimals and negative values too, so have a play with that.  Note I've said do not use in production, I haven't tested it or anything, but have a look at that.
So the next technique is binary strings, so this is the binary representation, a 8-bit representation of the number.  The max value is ... and why it's minus 1 is because I'm storing the binary in a format called two's complement and I will explain why that's important in a sec.  So now we have a bigger value than we started with, with numbers but a smaller value than our base 10 system.  That's because we are in base 2 and can't store as much information but it's still 1,347 kilometres on this sheet of paper with every centimetre being a thousand times bigger so still a very big number but let's take a look at subtraction in this system.  So we have the number 5 and minus 3 in binary and we know this is going to give us 2 and we can use this method called the two's complement to model this in a different way so first of all what we do is we flip the bits and we add one, and then we can see if we can just add like we would before, so in binary addition one plus one, you carry the one and you leave a zero, so we go over, now we have 1 in this column, this carry situation again, 1 plus 1, so zero and carry the 1.  Now we have 1 plus 1 again, we put 0 but we are carrying a 1 into this area we don't care about called the overflow bit and you just throw it away.  What's interesting is we've ended up with the number 2 so even though we had this subtraction problem we were able to model it using addition.  So we started with subtraction, we flipped the bits - oh, you can see the animation but I can't.  So we actually ended up looking at it like this.  We have been able to model subtraction as if we are doing addition which is a really nice way of looking at the problem.
Let's go bigger.  Where can we go from binary strings?  We can look at hexidecimal strings.  Hex is just a mapping 0 through 9 and 0 through 9 and A through F is 10 through 16 so we can store values in each slot of a string so now we have this new max value of 16 to the n minus 1 which is bigger than we had in decimal but it will have a bad subtraction story, but we are now moving in the direction of trying to chase bigger and bigger numbers so this one is now 5037km on paper.
This leads to the question: what could we store in the slot of a string, what's the maximum thing?  This leads to my final technique, 16 bit strings and to understand this we need to understand how strings work a little bit better.  To understand strings we need to understand Unicode so Unicode is really simple, just a map of symbols to integers or symbols to code points.  Code points, they just decided arbitrarily that these symbols map to these integers, that's all it is, and there's about 1.1 million of them.  JavaScript is a language that has decided that it's going to treat every 16 bit unit of a string as one character, and I am going to show you what that means.
Let's start with this string, the letter E.  It equates to the Unicode integer of 101.  You can pull that out from the string and it's going to give you that integer back but you will see in hexidecimal, it has a length of 1.  This will be true for any character that has a Unicode code point between 0 and 2 to the power of 16.  Things get interesting when we start to move to characters that are bigger than to the power of 16 in integer value.  So in this case we have an emoji which equates to a code point and you will see that it actually equals in JavaScript two different Unicode strings.  It has a length of 2 so even though visually to us it seems like it's one character according to JavaScript as a language that we deal with it's two.  This gets even more crazy when you start to introduce things like modifiers where, according to Unicode, it's two huge numbers but JavaScript needed four 16 bit strings to represent that.  So it looks to us like one character, JavaScript is calling it four.  So really the biggest things that we could store inside one slot of a string is anything from 2, 0, to 2 to the power of 16.  So we have 2 to the power of 16 things we could store in each of these slots.  To put it into perspective it if we look at the piece of paper, with each centimetre being a thousand times bigger than the one before it, it would be from here to Sydney and a little bit back again, how much paper we would need to record that value.  But what about operations?  You know, if we had a string hash plus dollar, what does that give us?  We saw this method before where we could pull out the integer value so we could simply pull that integer value out, do the addition and if we really wanted we could save that result back into a Unicode string so if you didn't know hash plus dollar equals G.  Cool.  So we've got a pretty big increase in scale and it has pushed us to the limit of what we could do with strings so where do we go from here?  Let's have a look at arrays.  So firstly we had a string and I have been very deliberate with my language in saying that a string has slots.  Now, we can also think of an array of characters, so we can think of a string as an array of characters but we also have arrays in JavaScript so technically we could store anything we want in one of these slots, we don't have to store just one character and the conclusion of that is we could store one of these superstrings that we've created in each slot of an array.  So how long is an array?  Well, an array is 2 to the 32 minus 1.  Just so you know.  Which means our new max value is this huge thing here.  To put into perspective how much paper we would need to store that number, you would have to go from the sun to Pluto - I like mentioning Pluto because it was a planet when I was young and I like keeping it relevant - so from sun to Pluto 135 times.  That's how much paper you would need.  Yes, it's about 3 trillion kilometres worth of paper with each centimetre being a thousand times bigger than the centimetre before it.  These numbers, I can't even process them.  This is just one level of deeper arrays.  There's nothing stopping us having arrays of arrays, or arrays of arrays of arrays.  The numbers start to get absurd and I couldn't think of any good analogies for them anymore.
Now, I have been thinking of mirroring, right, can we actually store these things?  So let's have a look.  We know we have 16 bits per slot, there might be some optimisation under the hood but let's assume 16 bits per slot, 227 slots, so the amount of bits is about 2 billion bits or 268 megabytes to store one of these strings and if we are trying to store an array we have 268 megabytes per slot, 232 slots, about 1 million terabytes to store these things so definitely something you don't want to be doing, so we are going to stick with this.  268 megabytes is something we can probably deal with.
Now, what we could do is if we were running in Node by default you get about 1.7 on a machine, you could increase your memory, but for starters we are probably going down an approach we shouldn't be going down so let's take a step back and think about what we've learned from looking at this string approach to doing math.  Firstly, we learnt that we can do almost any operation if we can add.  If we are using a binary system, if we can add, we can kind of do lots of different operations.  And we can add two numbers - we can add numbers together, potentially really big numbers.  We only need to look at two digits of that number at a time so just kind of looking down the column, shifting to the right.  Shifting to the left sorry.  Okay, so let's take those learnings and apply them somewhere else so say we have this file and it's encoded in UTFA which means you have flexible 8 bit encoding.  We have a binary string that's huge, much bigger than we could store in memory at once, and let's say we have two of those files.  We could open a stream to those files, this is sort of like a live connection to the file without reading anything in, and then we created a buffer where we are just going to read in one byte at a time from each of these files, and this is why it was important that it was UTFA because 0 and 1 fall in the first eight bits, we will be able to read in one digit at a time which is what we want to do, read in one digit at a time from these files.  So we read in one digit at a time, we do the operation, might save the overflow if there is one in memory for a bit and then output that one byte at a time to an output file, and this is pretty cool.  So this means we could actually add incredibly big numbers that we could never really store in memory, by just kind of just looking at two little things at a time and just adding them and kind of passing it on.  I built this as well, it's there if you want to check it out.
We have two input streams, say 1 and 0, you add them, save and then add to the file.  It's very similar to what we had before where we just keep shifting down.  We can do this on numbers that are much bigger than we can store in memory, so now this table starts to break down, right?  Our limiting factor is not - I'm sorry, I know you probably can't see the bottom of the screen right now but I've just written "infinite" and your limiting factor is the number you have on your machine which is a pretty big increase in scale.  I didn't even bother to figure out how big in terms of kilometres that would be.
But we can take this further.  What if we weren't even limited by our own machine but instead distributed this number across one machine so no one machine could see the whole number at once but all these no ones had pieces of the number, we could store them using that and also create some sort of protocol to do distributed operations.  Because we don't actually need to see the whole piece of the number at once to see an operation, you only need to see two digits you could distribute and then screen that output to someone who cares about it, so now the limiting factor isn't our machine, it's how many machines we have access to.  All right.  So we went big, we went really big, probably bigger than you thought we were going to go today, the limiting factor being the amount of machines that you have.  We actually learnt a lot from implementing a numbering system using strings which you might have thought was a bit strange to start with and we were able to take those learnings, some of the nicer patterns we found about dealing with strings and we were able to apply that in a completely different way to build on the system that maybe we didn't think about when we first started.  So my big take away from today is: don't be afraid to try something a little bit different.  You might actually get some learnings from that that you can apply to some other problem, or to find some solution that you didn't even think about when you first started.  Yes, so you never know what you will learn and where it will lead you.  Before I finish, I just want to acknowledge a good mate of mine, Stephen Campaign, a math mate of mine really helped me out so a big shout out to him and also my amazing colleagues whose ear I have been chewing off over the last few months wrapping my head around these problems.  If you do want to use big numbers in production there is a library, you can use that.  Also if you are interested they are looking at putting infinite precision integers into JavaScript, there's a draft stage, proposal hub you can check that out.  Great.  Thanks, everyone.  [Applause]
>> Wasn't that fantastic?  That was absolutely incredible, and that gave me as somebody with, like, the fear of the numbers the warm fuzzies, so I was pretty happy about that.