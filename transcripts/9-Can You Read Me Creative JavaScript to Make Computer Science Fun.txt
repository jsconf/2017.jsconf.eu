"Can You Read Me? Creative JavaScript to Make Computer Science Fun"
Mariko Kosaka & Suz Hinton

    >> Thanks, Monica.  Well done.  Hi, I'm Elly.  I'm taking over for Carolina as MC and shipping you off until party time before heading off for the day.  I hope you guys are having a great time, availing yourselves to the facilities, drinking the coffee, drinking the beer, eating the frozen yogurt, working on your Berlin tans out at the beaches out there.  So I am really excited to introduce to you Suz had I known don and Mariko today.  Suz is from my home town originally, and Mariko from Tokyo originally.  They both in NYC, and they're best buds right now.  They run Brooklyn JS.
    SUZ:  I get the easy job.
    >> Yeah, so they're, like, big JavaScript weirdos basically.  They're here to do some weird stuff with JavaScript with us today doing creative JavaScript to make computer science fun, which should be really nice.
    SUZ:  We're almost ready.
    MARIKO:  Am I standing on the wrong side?  Yeah, this side.  So I guess we start.  Hi, welcome to our talk.  My name is Mariko Kosaka.  My Twitter handle is @kosamari.
    SUZ:  And I'm Suz Hinton, and my Twitter is @noopkat.
    MARIKO:  And we are web developers, not exclusively JavaScript but we like to use JavaScript in weird places.  So, for example, Suz makes this awesome, awesome library to control hardware and to put pixels in hardware with JavaScript.  I'm involved in a project to make an electric knitting machine so that I can make textile design.  That was convoluted.  Anyways, so we basically go to same meetups.  We see each other pretty much every week, maybe and we, at this point, we are like BFFs that finish each other's sentences.  Yesterday we flew in red eye, super jetlagged, some tired.  We were rehearsing this talk and we just couldn't -- but we were shouting same words at the same time.
    
    [ Laughter ]
    
    So a year ago at one of the meetups in New York, Suz proposed to me saying, like, hey, do you want to maybe sometimes work on projects together?  And maybe sometimes, like, talk at a conference together?  And without thinking anything about what it's going to be, I just said, "Heck yes!" But we didn't really figure out what we wanted to do immediately.  We talked about, what about this, what about that, we spent months and months just talking about the idea of doing this secret project together.  But that quickly ended when October 6th, 2016 last year, I saw this tweet from Jan, one of the curators of this conference said, can you give us an update to the fax machine.  And one of my other friends in Melbourne said, is this still in use?  I have a secret wish that we own one and send each other little drawings and I thought this was a perfect idea.  Suz, immediately saying, like, hey, do you want to do a fax machine, and without me explaining, she replied, "Love it!"
    SUZ:  Great.  We had to come up with a few more constraints other than we're just going to make some fax-machine-related thing.  So what we ended up deciding on is we were going to build two separate machines and that's where the project was going to diverge.  And so what our machine needed to do was it needed to be able to accept any kind of data type that one of us sent to it, and then it would be able to interpret that, and then output it in whatever way we chose to.  So, essentially, if Mariko sent my machine an audio file, or an image file, or some kind of binary data, it knew what to do with that data and vice versa.  So if I spent something to Mariko's machine, it would be able to understand what to do that, and what it was.
    MARIKO:  So on top of that --
    SUZ:  So on top of that, we ended up even with more constraints, Mariko decided to create her interpreter on the browser, and I decided to create mine only on the command line console, no browser allowed.  Scary for me, but yeah.
    MARIKO:  And we decided how we're going to do this project and how every day of each transaction, we're going to make a journal on documenting whatever we did on our own, and kind of sharing that journal together.  But every project needs a good name.  Like, we are the kind of person who starts thinking about logo even before we start the project.  And so we talked about this idea of fax machine and we were looking at Wikipedia, fax machine comes from facsimile and we really liked the idea of getting binary data and interpreting it so that we can make something like what they sent.  And so we decided to call it Make Alike.
    SUZ:  We thought it was a really adorable name so...
    MARIKO:  So we did one data exchange and we wrote our own journal and that's what we won't do today.  So I'm going to go into my presentation.  So my bit, I called my Journal Code, Journal 00 because I'm a JavaScript developer.  Like Elly has to start from zero and then I titled, when I decided we were going to look at binary data and decode it in the browser, I was super, super excited.  I love looking at hex code.  But looking at this I can exactly tell you how many patterns are in this pattern code, and about how how big that is, and to the point of I kind of notice, like, certain sequences and then I can tell the color collection of those things.  I spent a lot of times looking at those things, and it's like a puzzle.  So Suz told me that she committed the binary file so I pulled down.  We use GitHub -- and so I pulled down on GitHub and by just habit, I typed next command, open, dot, for the next whatever command to send and we talked about because it is a project, it would be like no cheating.  No putting on external software, no putting on, you know, easy way out, we were going to do the hard work, the groundwork ourselves.  But in through that, it was so fucking helpful that they decoded that binary for me on cassette tape on preview, and so I messaged Suz and said, I'm sorry, the OS decoded for me already.
    SUZ:  I was so devastated because it took me hours to pick this particular image and then I had to start from scratch and find something really quickly.
    MARIKO:  So after that, she sent me a new file, and this time with even the preview finder, it was a text file.  She told me it was an image, that was the only clue she gave me, but it was a text file, and I got to be a binary detective.  And so the first thing I thought was what if I miss inform the HTML element, what if I give the HTML element text file, are they going to be unhappy and give me an error message and then I have to investigate -- so I got through the HTML and the browser is also helpful.  So even though I was thinking that this is a binary text file into source of image element, so they should, like -- but they would go ahead and interpret it, and show me the picture.  So the this is second picture.  And Suz keeps talking to me about, like, the order is really important.  And, like, giving me clues or something.  So can you, like, elaborate?  Because I haven't figured out any connection between the cassette tape and that.
    SUZ:  Yeah, so there's a lot of clues in this picture but I think it's going to unfold as we send you more.  So I'm going to send you more files and this is the first clue and I think this is the hardest one because you won't see the pattern yet.  The format is a clue, the color palette is a clue, and the subject matter is a clue.
    MARIKO:  That's good to know because I've actually investigated the format for this journal.  So at this point I was like, I can't really be a browser detective because OSes are super helpful, and browsers are even more helpful because they're decoding for me.  So this plan on being a browser detective isn't working.  Instead I'm going to be a browser anthropologist, and observe the habitat of the HTML element and how they're interpretation my binary data.  So this was my first research.  I picked other media elements and put the text over it to test, is browser really smart enough to know that the file is image, or the file is audio.  I load it in the browser, and then, indeed, browser only decoded the file as image and then failed on audio and video.  It didn't play at all.
    So this proves the hypothesis of those media elements knows more than input because when we code, the form inputFileElement, we can access the data about file name, type, size, last date modified, it's kind of what you get, like, on the browser finder, the metadata, and those come back as, like, text, or as type text, plain.  So input level, they think it's a text file but when you send it down to the media element, they somehow figure out that that is a media source file.  So I kind of mentioned that the input element, looking at the metadata is, like, previewing in the Finder.  So when we double-click on the files, the files open up, or iTunes start.  So what's the equivalent of double-clicking on those files and letting the computer figure it out?  So in browser you can use something called FileReader API which basically reads the file for you, and returns the value, and the value, you can specify what kind of value you want.  So, for example, the leadAsUrl, you basically gets the C4 stream back, so that's something you can use, by letting your user quote-unquote, upload the image, but, in fact, it's all done on client side and changing the background.  You can also do leadAsText which returns the text of the things.  Sorry, my words are not coming out.
    
    [ Laughter ]
    
    You can also leadAsBinaryString, which somehow turns out, figures out the string.  The last one that's interesting is leadAsArrayBuffer.  And this is one that you can't console.log because it's an arrayBuffer.  Any even know what buffer means, and as a web developer, I ran into MDN, and here's what I learned about it.  Array buffer is, like, a masterpiece that belongs to a museum that belongs in the glass case.  You can examine it, you can examine the cutout of it, but you can't touch it.  In order to touch it, or do any work on it, you have to do it on your own, whatever tool, whatever format, whatever binary format you want, you have to create a new observe representative of the array buffer in order to do work on it and the way to create those are things like typeArray and dataView.  So on lead on load, you put the and then you access it, toString it, and then lead in hex and then something like 42 comes back.  So in doing so, I noticed that if I do it in text, I see a lot of, like, metadata already.  I noticed that there is a pattern that they are putting image from data on top of a file.  And, you know, looking at these, and being an awesome JavaScript web developer, I was, like, can I maybe just, you know, like, you know, and quickly I was like, never mind because, like, A, I know enough that it's a bad idea.
    But also, it wasn't the point of, like, me figuring out how to do it, my investigation of being a browser anthropologist was figuring out how the browser does it.  So thinking about browser, I was like, how the hell all the different kinds of browser takes one single code that I wrote, and all displayed somewhat similar and then came down to web standards.  So all the way a browser should behave is all defined in web standards.  So I was like, okay, great, is still web standards for leading how to lead what the file is -- what the file type is, I guess -- there is?  It's called MIME insisting on WG Standards and if you read the introduction, you don't have to read it.  It basically solves the same problem of what if a malicious user uploads a script, or wrapped up as HTML and you accidentally execute it?  You have to make sure that the binary level, what that actual looks like and this was, in the introduction, that was great.  Okay.  Give me the specification to that image.  And this is the graph for the image type pattern and I was like, great, those are the steps for doing those things, and step-by-step defining it.
    SUZ:  You went deep, Mariko.
    MARIKO:  Read the byte sequence to be matched, and the MIME standard.  And I was like, am I supposed to understand this?  Is there a hidden web development class that I took and I missed?  Like, you're a native English speaker, do you understand this?
    SUZ:  I think it feels more philosophical and Shakespeare than the actual spec.
    MARIKO:  So I asked some of my friends who works on standards and edited the standards, and Alex roughly said that this standard specification is a particular dialect of English that compiles to C++.  So I was like, okay, these documents, even though they're in English, the compiler target is computer, and not me.  And so I spent a few hours over the weekend.  You can see, I pretty much visited all the links except for bytes.  Bytes are still left in blue.  Somehow figure that out, what they're saying is lead the first bytes of the file and then compare it to the one on that column, and then compare that result to that one on the second column to make sure that pattern mark, whatever that is is correct.  So I'm like, okay, great!  I'm going to code, I'm going to make that thing that is 100% compact.  And this is the part of the talk that I'm supposed to tell you that I made this npm module that is 100% spec compatible, and I published it today at the conference.  But in fact, I didn't.  Because I'm still figuring out the configuration.  It's like, give me a break.
    So what I did, I still took the uploads of sniffing the binary, but not 100% compact way.  So what I made at the end is, like, this little app that has a fileInput element.  You can give them any file, and then I sniffed the MIME type and then put into appropriate media tag.  So if you give a text file that's actually an audio file, it puts in the audio tag.  Image file that is not having a file type can just go to image.
    And that was my first pass.  And now I'll move on to Suz.
    SUZ:  I have one question for you:  What format was the image I sent you?
    MARIKO:  That was bitmap?
    SUZ:  She figured it out.  Awesome.  So I'll start my part off with building blocks.  So if you'll remember, I only the command line available because I like using the browser as a crutch, but one of the things that I really love about the command line is pipes.  Pipes are awesome because this, for example, takes the processes that are currently running and pipes that into grep and with grep, you can kind of keyword within that list.  And this is what it looks like when you're running it.  You could pipe into grep and you could look at your batch processes for example.  So really what PS Pig is saying, hey, grep, I have this list of processes and grep total says, hey, thanks, I'm just grabbing that from the pipe and I'm just going to list out the ones that have bash in them.  So that's pretty straightforward.  So the first thing that I wrote was a really simple pipe such as a hello world so I know how that works in things like Node.js because if you remember, like it was in JavaScript, and mine were in command line only.  So mine are, like, shell scripts that you can run in Node.js.  So that wasn't really useful, and so I thought, cat is a highly useful command that people use, and they pipe it into lots of things.  So, for example, you can do file.text, I could supply that to cat, cat is going to dump out onto the console, exactly how that file was, and then from there, I can actually take that output and pipe it into something else.
    MARIKO:  Can I just stop and comment on what that cat is saying?
    SUZ:  Yeah.
    
    [ Laughter ]
    
    MARIKO:  I'm just commenting.
    SUZ:  And so I've just simplified this slightly because cat has a lot of different things but I've done the basic cat command which is to basically open the file and pipe that into the standard process, which is to the command line console.  So that was kind of out of the way, so the way that I tested it was I made the file executable and then I fed through Ada Lovelace quote and I thought, okay, I'm fine for Mariko sending me the first piece of binary data and then she opened a pull request and then she promptly merged it easier had.
    MARIKO:  Because I can.  I didn't have attenuate for you.
    SUZ:  There's no rules when you're on GitHub with creative projects.  It arrived mysteriously missing a file extension now when I merged this down, I was so scared that I was going to accidentally open it, and this was before you accidentally opened mine that I was just super weird.  I just closed all my Finder windows.  I was terrified of the open command so I just left it.  So I ran it through my cat program, and this is what I saw.  And so you can see here that it's just a whole pile of gobbledygook, but when I looked the the headers of the file, I saw the clues, that kind of audio file is this so I can start decoding it?  So the first thing that I started here was this id3 tag.  Id3 tags were a standard that was made for MP3 files.  And the next thing I was was what is this GarageBand tag in here?  Did Mariko make me a song?
    MARIKO:  This is just a confirmation that I didn't have time to learn the full Web Audio API.  Which I didn't have time to do.
    SUZ:  I loved it.  It was a great detail.  And I loved this eye tune here.  Which is totally meaningless meaning that GarageBand -- 
    
    [ Lapse in Audio ]
    
    -- so what I did know was that it was an mp3 made in iTunes and I could move on.  So with my browser as my crutch, I was able to find a Node.js module that emulates the API to a degree.  So you do have to spin up an additional module called Speaker.  Speaker is great because it can attach directly to your drive on your computer.  And so I was trying to make this on a Raspberry Pi because I wanted to make a machine.  But also created a function with the actual data in it with the audio file, and I had to play that to the actual destination so I could play it to the system.  And from there I had to use fs to open the file, and so you can type the command file and then the actual file to open it, so I did that.  So this is what the command ended up looking like when I ran it on the command line.  And then this was when I heard the sound for the very first time.  So this is what I heard.  Hopefully... oh, no.  Okay.  Maybe we can go back.
    MARIKO:  This was, like, a particularly, like, hand-picked, hand-crafted piece of music.
    SUZ:  Clearly, it was, like, worthy.  And I thought, this is really weird.  She did this in GarageBand, and it's not really following normal musical aesthetic taste.  But I was like, wait a second, Mariko sent me a video several months ago, and it was this video here.
    MARIKO:  That one sounds more like actual music.
    SUZ:  So that was really cool, and it was something about Mariko's audio file and the give-away in the GarageBand file that told me that she made a picture.  But here's the thing, I don't have the GarageBand file.  And I only have the command line, so how do I visualize the picture she made for me, and maybe she didn't even make a picture and she's messing with me.  So what I ended up doing is, this is Raspberry Pi, and I can't use Chrome on it, I have to use Chromium.  I had to kind of stream the GUI channel over to the virtual frame buffer.  So X Virtual Framebuffer is a really great tool for doing that.  That then runs a HTML file on localhost with a canvas in it and an audio element in it.  And essentially the Web Audio API analyzes the frequencies because the frequencies can be mapped to notes which we learned earlier if you went to Ruth's talk, and I said, maybe I can map the frequencies like that and I could see a picture come out.  But I had to run this headless so I had to figure out a way to get the image from the canvas out and actually look at it, so I ended up taking the result in canvas after mapping all the frequency graphs on it, and I made that a basic coded string that I was able to DOM out into the console, I was able to take that string and pipe it out into another program I wrote, that's 64, and then converts that to a png file itself.  And then that would console.log the path to where that file is, and then I could pipe that into a great npm package called picture-tube which allows me to look at pictures in my console.  And so all of this was JavaScript from beginning to end, and this is the way that I had to do it all on the command line.  Good times.
    MARIKO:  Can I just comment the fact that I sounded super mean... I wasn't trying to be mean.  I thought it was cool.
    SUZ:  I was expecting PCM data and I was a little offended that you sent me compressed audio data since I'm used to working with PCM.  So this is the headless Chromium job.  I set it with a query parameter, so it could go fetch it in the API.  And there would be cases where I would have a bug in the code and the bug wouldn't send properly and so I had to put a 60-second timer on it and kill the process.  So that was fun.  The base-64 process there is taking the image data from the standard and it's -- sorry, it's taking the base-64 string and then it's piping that into an actual file, and then this is kind of what my final command ended up looking like.  So it's a rather long run.  It took me a while to write because I'm not a super fast typer.  So I'm drawing the canvas and then I use that as an argument to picture-tube in order to view the image.
    MARIKO:  This is what it looks like.
    SUZ:  Is this what you drew me because it's really not that good.  It doesn't look that good.  I mean if you squint, it kind of looks like a puppy that's kind of facing that way.
    MARIKO:  I can see how you might get this is what I would send because this is like what I would do for my textile patterns.
    SUZ:  I was expecting something different.  And so I managed to shell into the pi, and I managed to drag down to it, into a computer that has a graphical user interface.  So here's the thing, if Mariko layered several notes on top of each other playing at the same time, I don't really have access to that.  That's very hard for me to pull out pixels that are kind of laid on top of each other.  So this is the best I could do.  I ended up just pumping out a whole bunch of different frequencies to see if I could see patterns emerging.  This is actually what it looks like.  Not that great.
    MARIKO:  And this is the file name of the emoji that I used, it was heart, heart, heart, wink.
    SUZ:  So she mapped it to the file name, so I should have known all along.  But in my defense, if you look at it, when you layer it on top of, you can see the bits of silence between the shapes.  And if you really squint, I think that you can kind of make out, like, the peaks on the heart shape at the top, but yeah, I thought that was pretty cool.  So that was kind of my exploration of trying to figure out the mystery that Mariko had encoded in the MP3 file.
    MARIKO:  So what did we learn from this entire experience?  We had a few thoughts of what we thought we learned.
    SUZ:  We learned a lot.
    MARIKO:  So the journey, we realized that it's not about the end result; it's about the process.  The end result -- the tiny app that I made is super simple -- you could have made it in a few hours if you know your thing but I didn't know any of those standards, or binary, or array buffer or anything, and I learned a whole ton by making a tiny thing that does a maybe simple thing.
    SUZ:  I didn't have time to cover this in my section but I went a deep rabbit hole about the MP3 file format, learned a ton about that and then started writing a decoder, and started realizing that this is probably a path that I didn't want to go down under.  But that's why I cheated with the Web Audio API.  Yeah, learned a lot.
    MARIKO:  Next one, it doesn't have to have a point.  Many times when we mention to people, that, hey, Suz and I are doing a special project.  Everybody is like, what are doing with that special project?  You guys are starting stuff all the time.  Just do a project for fun.  It's like you learn a ton.
    SUZ:  It's your personal time.  So really do what makes you passionate and if that's a business, that's okay.  But for us, we just want to make a thing together, play jokes on each other along the way, and yeah, just teach each other stuff, too.
    MARIKO:  And a lot of times people think that we're doing this side project really seriously and then ask for, like, what's the weekly update kind of thing but it's a side project.  We have day jobs.
    SUZ:  Yeah, we went for weeks without hearing from each other, and, again, I never got to see that GarageBand file until we got to Berlin.
    MARIKO:  And lastly, having a friend who has a similar, like-minded understanding of what we do together.  I don't know if that language made sense, that might sound like spec language, was great.  One thing that I learned from this experience was not the few months be or the few weeks that we actually did the data exchange but the six or eight months leading up to it.  We decided to do a project, we were in it.  And then every meetup, every conference, every subway ride, if we see something that we like, we just wink at each other, hey, what do you think about that thing?  And it's so nice to have somebody who don't have to, like, worry about.  Like, hey, if I mention this thing and it didn't use like the latest Babel Translate, is she going to judge me?  It's like, this sounds cool, let's do it.
    SUZ:  You should always find your code weirdos that are weird in the same way as you.  And that's what I learned.  And on that note, we are going to part ways but we are just going to tell you about just a couple of quick things that we're working on.  I do a live twit stream almost every Sunday so I kind of code on open source and also on weird projects like this.  I secretly coded on the next step -- I don't know if you knew that -- I was was secretly coding on the next step.  It's switch.db/noopkat, and I call it multipaired programming because I just implement the suggestions that people have on the chat.  Which is cool.
    MARIKO:  And I started joining a tech concept called tiny humans in colorful boxes and this was something I was thinking, like, a data infrastructure.  I wanted to build an infrastructure and I wanted to make sure that our data is secure.  So I started reading up on encryption and secured Internet connections and things, so I started learning that stuff and put it on my Twitter.  So if you're interested, check out my Twitter.  And on that note... thank you very much.
    SUZ:  Thank you.
    
    [ Applause ]
    
    >> Thank you so much.  That was amazing.  I think you really cornered the market on having fun with JavaScript.  I don't think anyone is doing it better than you.  So we're going to have a quick break now.  Get caffeinated, get beered up if you want to start early.  You can also get your butts to the Community Lounge during this break and there's a lightning talk there that's what is live.js.  And these are the people who are doing the music during the breaks.  So if you want to go see that, check back here at 5:45.
    
    [ Short Break ]