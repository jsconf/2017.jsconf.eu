Claudia Hernández - Down the Rabbit Hole.  Javascript in Wonderland
>> All right, we're just waiting for a few more people to get settled and we will get right into the next talk.  Everyone, please welcome Claudia. 
CLAUDIA:  Thank you very much for having me here today. I'm so excited to be at JSConf Europe. It is a dream come true. My name is Claudia Hernández, I'm from Mexico and a huge fan of Alice in Wonderland and I work at Daily motion. If you have comments, suggestions or complaints, you can find me on Twitter as before. Don't hesitate. Enough about me, because you are not here for me, so, for the following three minutes, I'm - 30 minutes, I'm going to be your own personal white rabbit because I'm going to drag you with me into the rabbit hole at show you some really weird things going on in JavaScript. One things first:  I'm not an expert, but I'm a really, really curious person and I love to know how things work. This is one of the main reasons that I decided to do this talk. Most of the things that you're going to be seeing in the following slides are things that I have come across and, at the beginning, I didn't understand what was going on. So, the beauty of JavaScript. JavaScript is a kind of language where nothing is what it is. Because math.min is not math.max because in JavaScript, everything is what it isn't. Contrary-wise, what is is not in JavaScript. Two totally different totally similar looking - it's not what it actually is. What is going on?  I'm not going to go into detail in believes examples, but if you're curious about them, they have to do with inconsistencies in floating point numbers in JavaScript and other languages and knowing the difference between primitive and reference types. The thing with JavaScript is that JavaScript is very easy to learn. Everyone can do a console.log in their browser but it is harder to learn in a deeper and meaningful way. This is our first part through Wonder land. NaN literally stands for:  not a number.  Bess what?  Type of NaN is number. It is going - what is going on?  NaN is the returned value of of a mathematical operation that failed. We try to do operations both eperands are not number, or we do things that are not defined like dividing zero by zero or get the square route of a negative number, we will also get NaN. NaN is trying to tell us something along the lines of, "I tried to perform this mat mallal operation so I failed. Here's this fail number instead. Back"maybe the label NaN is misleading. Maybe it would be easier to think of it as "bad number, failed number, invalid" more than not a number. Because bottom line, NaN is of numeric type but it represents a value that could not represent a valid number. In JavaScript, mathematical operations can lead to an error or crash. So what if we wanted to know if a value is equal to NaN or not?  If this was your first guess, let me tell you something. Actually, NaN is not equal to, greater than, or less than anything, including itself. But why is that you may be wondering?  So NaN is not only a JavaScript thing. NaN is defined by the standard called the IEEE754, and, to keep things short, because this is a 30-minute talk, basically, what this standard tells us is there are 16,777,214 different floating point values as NaNs. What does this mean?  This means there are so many different representations of NaN that it is highly unlikely that one NaN is equal to another NaN. Nan is not equal to NaN. I think we agree that NaN stands for "not a number" so the only way if we know if a value is NaN or not is to use the JavaScript built-in function is NaN. Now let's talk about sorting arrays because that's always fun. Can you spot what is seriously wrong in this code?  In my world, 235 and 33 after the number 4, but in JavaScript, things are not what they seem. What is going on?  JavaScript is doing lexicographical sorting. What is that?  It is likes dictionary-like alphabetic type sorting, not numerical at all. For every character in the strings, it is comparing the unicode value. It is the unicode ID of any character. So, in this example, we have a colour array red and blue, we call the sort blue, red is coming before red, because of alphabetical sorting, but we have a numerical array with 80 and nine and this will be the exact same thing we call third method with those numbers as strings. Basically, 80 has that smaller unicode point value. In a more simple way, we can say that 80 is lexicographically less than nine and it starts to make more sense now.  If you want to know the point value of any character, you can use the string code, the method. 25 and 33 are indeed lexicographically less than four. When we're trying to sort an array, lexicographical sorting is not the first thing we want. What we are missing here is that the third method can take us a parameter compare function, so if a compare function is given, if a is smaller than b, we return -1. If a is greater than b, we return one, and b comes before a, and in any other case, we return a and b and zero - if you're as curious as I am, you wonder what is the algorithm behind that native sort method in JavaScript, and the answer is that actually it depends on the JavaScript engine, because the standard doesn't impose a certain algorithm to be used so every JavaScript engine is free to use whatever they want. Out of curiosity, if you want to know, Spidermonkey for Firefox is a combination of algorithms insertions for small arrays for performance, and V8 Chrome is using Quick sort Sort and Insertion Sort. There's an a fun fact for you people who love computer science. Now that we have finally provided the compare function, we can have a numerical sort. The tilde operator. How many have used this operator before?  A few of you. This is a bit-wise operator. What is that?  It's an operator that would take a number, transform it into a sequence of bits and then it will do some kind of operation on it and it will turn back an integer as a result and it is very important. Now, maybe just maybe, you're familiar with the bit-wise and the but those are not the same as the logical "and" or "or". Today I'm going to be talking about the bitwise not. What it is doing is inverting the bits in a sequence. I know we normally don't do these kind of specific to be operations in our applications, so let me put it this way. The operator is just doing this small algorithm. It's adding one and then changing the sign. We can pass the -2 and get along. Et cetera the million-dollar question here is what actual use in real life can we give to these operators?  So, one of it is by using a double tilde operator, bitwise, and we can truncate using numbers and this is quicker than using math trunk. We can use other bitwise operators to do the same thing, and, as I told you, this is faster. Another thing we can use with the bitwise is imagine that we want to know if someone is coming to the tea-party that we want to have later. So you know, the array function these index methods. The way this method works is that it will give us the position of an element if it was found on an array and, if it was not found, it would just return -1. A lot of developers have used this method, and they will do a lot of these things. They will compare it if the index method is bigger - all of this can be simplified by using the tilde operator. Basically what is happening here is that the let me was not found, the index method will turn back a -1, then we will pass this -1 to the tilde operator and it will transform it into a false zero. It will mean that the element was actually found in any other case. Now, before you start getting angry at me, I know that this is not very code-friendly but don't worry because ES7 has a new function called includes which will return us a Boolean that will save whether the element was found or not. Don't worry about. ES7 has our backs. Cool. Let's talk about for loops they can be fun. I once saw this in a JavaScript book and I don't get what it means, what's going on. Now let me bring you back to those days when you're learning about JavaScript variables, and loops, and you were so eager to learn everything. Let me remind you something basic about JavaScript and for loops. For loops have three parts, an initialisation, condition, and iteration part. They're optional in JavaScript. You can take the first part, declare variables outside a loop and it doesn't matter or you can remove the condition for it, and if you do that, JavaScript will automatically consider it as true and it is up to you to break the loop, or you can even take the iteration for a farther away, and this this case, the condition part is acting at the same time as a iteration part. Once this I drops until zero, it will be a false zero and get in the way of the loop. You can remove everything. If you do that, as I told you before, the cognition part will be automatically considered as true, and basically what we are looking for is just an infinite loop. So, cool. Let's talk about undefined. This is variable that has been declared but has no value on it. It is part of the window object. So, what would happen if we wanted to be really clever and define undefine?  Actually, the result of this piece of code actually depends on the browser that you're running it, so, for older browsers from internet explorer 8 and below, you could redefine on define. This has already been solved for modern browsers. Now I get it:  while it is becoming less and less of a problem, we have to take, I mean we have to care about these kind of issues because if you support older browsers, there is a possibility that people might try to define your own defines. The thing with JavaScript is that JavaScript rarely runs in isolation. We often run it with other libraries, with external code, so just be careful. But the madness doesn't stop there. Undefine isn't a reserve word in JavaScript meaning you can use it as a variable name which I totally don't recommend, of course. What have we learned so far?  Not a number is a number, that it sorts lexicographically by default. The tilde is not a bit operator and undefined, defined - sometimes. Am I boring you?  Is this like, not that fun?  No in wait!  Because the mad JavaScript party is just about to begin. And before I start talking about it, just a little bit of a disclaimer. The former content is designed to challenge programmers, not for practical use. Now JavaScript without letters and without numbers. Before I get into it, I'm going to keep repeating something that we have in here in the previous box.  Javascript is a dynamic-type language so we don't have to declare the type of data we hold when we declare it. This is a interpreter. When we mix types, we can have really, really weird conversions that can lead to really, really crazy results. What I'm going to show you is how to write valid JavaScript using square brackets, parentheses, curly breaks, the plus operator and the exclamation point. I'm not crazy. I've been talking about the previous slide about values. Here's the thing:  everything in JavaScript has a Boolean value, everything can be falsy or truthy. How can we know that?  The golden rule is this one:  everything in JavaScript is truthy unless it is falsy. The false values by default are false, zero, empty string, null, undefined, and none. The truth is everything else, and it could be a string zero, an empty area, an empty object. Now, the behaves. So, in this example, in the first one, what we are trying to do is we are trying to negate an empty array, so we are first in JavaScript to treat that empty array as a Boolean type, and, if you remember from the previous side, that an empty array is just a truthy volume, so we are negating a true so we get a false, and in the second example we're negating a false so we get a truth. By just using the class operator which actual function is just to transform things things into numbers. Guess what?  Once we have zero and one, we have a way to create any other number. You can picture it as adding one, plus one, plus one be until infinity. We can also convert things into strings. In JavaScript, you can only concatenate things with the plus operator or with add numbers. If you try to put anything else over there, JavaScript is going to automatically try to transform it into a primitive type, a number or a string. So in this first case, the first part is just a false, which is a Boolean type which is a primitive type, and an empty array is automatically formed by JavaScript into a string. So these actually give us a string false or string true. These work the exact same way for numbers:  we can convert numbers into strings using this technique. So what if we wanted to do bigger numbers because we're not going to add one plus one plus infinity. We can transform into strings every single detail and then concatenate those details back and transform the whole thing back into a number, so 123 actually looks like this in alphanumeric JavaScript. Now that we have access to the words and vocabulary, we can transform it into strings as I showed you before and access every single character as if they were arrays. So, if you're following along, perhaps you might notice that what we can do is we can try to make up functions and words that actually mean something to JavaScript. So, Martin - he should be somewhere in the crowd - creator of jsfuck. I love the term, because I think it is really clever. What we are trying to do is given the set of characters of words, we're trying to make up junctions that mean something to JavaScript. To keep things short, we can have access to call, concat, constructor, filter. How does this look in action?  I will show you step by step so you understand. This piece of code is doing another one in your browser. Here's how it works. The first part is just an empty array. No surprise there. The future segment is trying to access the filtered function of that empty array which is a function. The constructor part is just getting that constructor for functions. And the constructor of functions can actually take a parameter, a string, that will return back and a new function with that string as its Buddy. So now, you can finally get the last part is just out executing that new function. So basically, it will give us in our browser another 1, and the code behind it is the code actually used to make this work, and it does work. So, yes - if you're interesting interested in that technique, you can find a lot of converters online and I encourage you to check the open source - the code source, sorry, and there are jsfuckdemo, JScrewIt, and the most well known is JSFuck from Martin. There is no limit to this. I came across this repository called JS screwed rewriting the whole JS library using this alphanumeric technique. This is the source code. A lot of people have way too much time on their hands - not like me!  At this point, you might be wondering like Claudia, I would never write JavaScript that way. Why should I even care about these things!  One good reason could be security. This is a Tweet from a few months ago in which Martin was pointing out to a blog post from a security researcher that he found a - on eBay.was able to inject malicious code into eBay by this technique. It was filtering text such as script or iFrame and not aware by this technique.  I guess by this time, it is already fixed. Yes, and we are reaching the end of our journey. This is our last part. I can't leave without talking about arrow functions because they are - array functions. This is common to see. It doesn't work because the context of the function that is inside the function is no longer in the same context. A lot of developers have actually solved this issue with other - by adding new variables such as that equals this, but actually, there is one thing:  arrow functions don't have a arguments, they don't have super and they don't have new targets. Any reference to them will just lexically resolve up. We can rewrite the - we will reference the full contents and we will have something being displayed. What if we wanted to be really, really stubborn and we actually wanted to - since arrow functions don't have a context at all, there's nothing the bind method can actually grab on. So I guess, what I want to say with this last part is that arrow functions are not about writing less, they actually have a behaviour that we have to learn how to use and use it accordingly. Was it all a dream?  Sadly, no, this is real JavaScript. These are the things we have to deal with every day. So, but why should we care about all of the things that I just showed you?  First of all, knowledge is power. We have to know when writing the code, we're writing and how it works. We have to push the limits. It is us who has to make JavaScript this amazing language that is it running on our servers on the December stop everywhere. We have to push it to the limit. We have to break the rules. Don't forget play is learning. This quirkiness of JavaScript makes me want to continue working on it, make mistakes and just play around with it, and this is ultimately what nation me every day a better developer, just diving into the language itself. And it is the power of the language. This is a code that I really like that says, "JavaScript is a language that has survived not despite its flaws but because of them." And the last thing:  I just want to read this quote from a really, really good book that I recommend from called If Hemingway Wrote JavaScript:  the best JavaScript is those who succeed easy language, they develop their own idioms and their own voice. That's all from me. I hope you liked it, and danke schön. [Applause].  
>> Thank you so much, Claudia, for the fantastic presentation. As everyone is escaping to lunch, I have some announcements, one moment!  
So, one announcement is we have community talks during lunch again. The one that will be running now is lightning talks about DAT project and UX night school and there are also workshops in the Mozilla booth around Rust and WebAssembly done by Lin Clark and another person, whose name I can't remember off the top of my head. The final announcement is we are going to have a panel on the TC39.  If you've been curious about how JavaScript is standardised, how we came up to the point of having ES6.  I would like to introduce a couple of the panel members who will be on that 4.15. Can we have a round of I have an applause for these individuals. And also James Snell is here. I didn't see him there. Yes, these people will be on stage. I will be asking them questions. If you have questions, we have a hashtag been it's, this, C39qs. If you have asking to ask these people, we won't be able to do live questions, so that's how best to get in touch. Yes. I hope to see you there. 