"Building High-Quality JavaScript Tools"
Chris Pojer

>>    How are you, everyone?  Everyone had lunch?  Okay.  Everyone is asleep as usual.  I hope everyone grabs coffee and everyone is ready for another round of talks -- awesome talks.  Get seated, get comfy.  The first talk, I would like to invite Chris, who works at Facebook.  Give it up for Chris!
       
       [ Applause ]
       
CHRIS:  I'm Chris.  I work at Facebook.  I'm an engineering manager on the JavaScript Tools Team in London and today I'm going to talk about building high-quality -- 
      
      [ Lapse in Audio ]
      
      -- and to make -- and I'd like to show you how we applied a product mindset to Jest, our JavaScript framework that aims to make testing painless and I want to show you how it works to rebuild it.  By a quick show of hands, how many people have heard of Jest?  Who is using Jest?  Okay.  That's awesome.  If you're using it already, I'm not going to try to convince you but if you're not using it, I want to convince you more.  So unfortunately, testing with Jest wasn't as painless as we wanted it to be.  Everyone was starting to adopt Jest, you know?  And I'm not making this up.  This is an actual tweet about Jest from about two years ago.  This is never something you want to hear from a project.  We knew we had some work to do.
       And at Facebook, it wasn't that much better.  Jest worked okay as a tool so, you know, write tests for your JavaScript applications but here's the thing, in this oil painting, you can see a party going on here.  And this Jester, he's so gloomy, and sad.  And this is literally the experience that people had at Facebook when they were dealing with JavaScript testing.  Everybody was super excited about building React applications but we found that no one was actually writing any tests because scripting with Jest wasn't great.  And so we decided to rebuild Jest and turn that sad Jester to a happy one.  But you might be asking yourself:  Hold on.  Who needs testing?  Who cares?  We realize that Jest isn't great, but maybe we can get by without any testing.  But, of course, testing is an important part of the engineering process.  It significantly influences engineering behavior and we learn that people write differently with or without a test framework.
       And to be specific about this, it helps by enabling a faster iterative development cycle.  It makes sure you have four bugs in your applications and you can make releases more often.  So when we go on to improve testing, we can look at it as we would at any product.  You know, like, what do you do with it and how can we make that experience better?  So for Jest, it's about what do you want when you're writing a test runner, and what do you want when you're writing tests?  For running tests, I should get feedback as soon as possible, it should give me a signal for failing immediately.  But for writing tests, I want to have all of them available to me but also I want great documentation to I can learn how to write effective tests and as we developed these requirements, we can come up with three things.  One of them is performance, the other one is features, and then adoptability.  All three of these requirements, they're equally important.  You need to fulfill all of them at the same time to make a successful product.
       For example, if you're building the most feature rich test runner, but then it's really, really slow, nobody is going to adopt it, and, at the same time, if you're building a really, really fast test runner, with no features, again, nobody will adopt it.  And, of course, if you are building the most amazing test runner, and nobody's using it, then what's the point of all of this?  So I gave you a bunch of buzzwords but if we peel this product layer back a little bit and look at an emoji, about what it was like an engineer working on this, this was really, really hard and painful.  We had something that didn't work well and we had to fix it.  And I came up with these three things that help -- that help you understand this process to make something great and it's:  Fix, rewrite, and polish.  It's kind of like FRP, functional reactive programming, but this is fix, rewrite, and polish.  And let me take you through this journey by talking about the three major requirements.  And first is performance.  Performance at scale is really important actually.  At Facebook, we realized we had thousand of test suites and a slow test runner and so we fixed that.  And, naturally, your instincts would tell you, let's rebuild the new thing.  But at Facebook we couldn't do that.  But we learned from past experience that big rewrites take longer than anticipated and sometimes they don't even work out at all.  So we decided to improve our testing framework by not explicitly rewriting the whole thing, but by making major changes incrementally in small parts of the framework itself.
       And I want to stress that it's enough to make 1% improvements over time.  Here's where it helped.  Internally, at Facebook, we have thousands of test files and tens of thousands of modules.  You know, we have a lot of information that we need to keep track of to run tests.  It's not just which tests are associated with which modules, it's also which modules are associated with which tests so that we can run the correct tests when files are changing.
       So we rebuild the system that analyzes the entire file system, and then extracts metadata from all the files that we care about, and then also tracks dependencies.  For example, if you're using Jest and you're using the store file up there, it knows not to use the entire store test, with all the thousands of files we have.  We also have a system that parallelizes across worker processes by looking at data from previous test runs.  That makes tests a lot faster.  And then as a told you, we made a lot of small improvements over time.  We changed how we cached transform files to make them more effective.  We improved the -- because we haven't, like, worked at Jest for a while, and then we just figured out what alternatives have been created since then.
       So now that we have performance in a good state and we can run Jest with tens of thousands of test files, we need to look at features.  Jest comes with dozens of awesome features out of the box, but today I'll only focus on three of them.  First one is the improved output, then we'll talk about this immersive watch mode that sucks you into Jest, and you just kind of stay there, and it's an awesome unit-testing experience, and then we'll also talk briefly about the snapshot assertion.  So let's focus on the improved output first.  This is Jest used to look like.  Log messages all over, and stack traces that didn't matter, and you have a stack assertion where you're comparing two objects and you have no idea what's going on, right?  We realized that Jest was okay when tests were passing but the value of a test framework is to actually give you a signal about failing tests and helping you resolve those issues and so we just rewrote the assertion library with the product mindset to see, what do engineers want to see when a test is failing.  So, for example, we color-coded everything so that you know what is green and what is red and we're also showing you a div when two objects don't match up so you know exactly what's going on.  The exciting thing about this is we gave Jest its own identity.  When you see a screenshot of this framework, you instantly know that it's Jest.  It's awesome.  We also have this concurrent runner which is awesome.  It tells you which test is running right now, and how long it's going to take based on previous test runs.  What's also awesome is Jest takes a note when it's failing, and next time you run it, it actually runs the failed test first to give you a signal immediately because that's probably what you care most at that point in time.  The next thing I want to talk about is the immersive watch mode.  It just runs tests quickly and then shows you what's happening and then what you want to do with it.  So when you call it, you call it with --watch, and then you have the p, for example, where you have this pattern mode, and then you have this typing mode where you can select from a dropdown, Jest knows everything about your system, and your and knows exactly which version you have.  In the next version of Jest, we extended this a little further.  You even have keyboard navigation in this.  I know I've been talking about CLI tools, but these are all great CLI tools and a great developer experience in them.  And then finally I want to talk about snapshots.  Have you ever written an assertion like this, and then you don't know exactly what you're going to put in your test, you don't know exactly what the output of your function is?  It happens quite often, right?  We do what we always do, we comment out this assertion, and we log the value and we take that and put it back in our test and we know what is going on here.  And judging from the faces that I see, I know that you are as guilty as I am.  So we found that people weren't writing inform tests from code that could benefit from this.  And so we introduced this new assertion that's called toMatchSnapshot() and here's how it works.  The first time you used it, it will inspect the output of your code, and Jest will record it a snapshot, in a snapshot file.  And then the next time you run it, it compares the output of your code.  For example, here we're changing a React component from Facebook.com to instagram.com, and Jest will yell at you and say, change in your code has changed, is this intentional or not?  And you can say, I'll pass in a flag to update all the snapshots.  All right.  And a bunch of you might be looking at me like, hold on, Christoph, what are you doing here?  This is not testing here at all.  But we found that it's actually better to be able to create these kinds of tests for regression testing, for example, really quickly instead of just waiting until that code hits production and that is the first time that anybody is ever running that code, right?  So it's preventing a lot of issues for people.
       And snapshots, I want to be clear about that:  They don't replace conventional testing, or all the other assertions.  It's just an addition on top of those.  It's just one assertion among 20, or 30, or however many ships with Jest.  The difference isn't between snapshot testing and utter assertions, the difference is between snapshot testing or no testing at all.  There are products like the JavaScript Farmer, where I'm not confident it would exist in its current form if it weren't for snapshot testing.  It just couldn't have moved as quickly.  And as you know by now because I've told you, Jest is a great test runner, like this jester in this photo, it takes care of everything.  Which brings me to a really exciting announcement.  It's actually really big but in the end, it's kind of impressive.  I'm going to show you one more feature.  Have you ever found yourself, like, juggling multiple projects in one day and you have, like, a really hard time.  Imagine you're building a React front end and a Node.js backend, or you're working at Facebook and you're having a terrible day.  You're trying to debug a bunch of projects in a single day, and you have a bunch of test runs on a bunch of different products and that's not really fun.  So we taught Jest how to juggle and we call this the multiprocess runner which leads me to this incredibly unimpressive demo.  In the next version of Jest, Jest 20, you'll be able to pass anything that you want.  It will watch all your projects at the same time in a single instance.
       Here, it's going to be running a few tests in watch mode.  I'm starting it up with a bunch of products like Yarn, and Jest, and Relay, and React, and you can run these tests across you will of these products.  So that's going to be shipping in the next version of Jest.  And finally about features, I want to say that the experience should be delightful.  I don't want to fight with my test runner because only if the experience is enjoyable, then that will actually make people want to write more tests.
       So now that we've looked at performance and features, we should also talk a little bit about adoptability because we spent all of this time at Facebook to make Jest really, really good and now it's -- we just want to you give it a try, right?  How do you get started with this?  The great thing about Jest is we've turned it into this zero-configuration framework.  It ships with a ton of features out of the box, and all you have to do is install it with Yarn.  And then you go on to do a simple test.  And then you just run it.  We also managed to bundle Jest with other JavaScript tools to form a more cohesive development experience.  If you're using React Native, or Create React App, you don't need to set anything up.  This also leads me to another small announcement.  So the JavaScript tools team in London at Facebook is also working on Yarn, the passenger manager.
       Next week, we're going to ship a really tiny command that I'm excited about.  It's called YarnCreate and it's extendible and you can look at it as your new entry point for any new reaction.  So you can say yarn create react app, or yarn create native file and you can create your own like that.  So this is a super sweet way to get started with something new.  These low-friction ways are something great and you might even get started on your next project with Jest, right?  That's not enough.  We also need to figure out how to make Jest work for you when you're already using -- when you already have a big project.
       When you peel back the outer layer of Jest, you should ideally also find things that make sense on its own.  And that wasn't always the case.  Not long ago, Jest was one big repository without much internal structure.  So we did something super obvious, we introduced structure by turning it into one big module in a repository.  We actually split up Jest into 13 individual packages that can be reused in many different contexts.  We're talking about pulling things apart from one big giant thing into many, many small packages.  This helped with the separation of concerns between the different modules and it naturally led us to learning Jest into a platform.  We actually ship all of these packages to npm and you can install of them individually and use them in contexts that sometimes don't even have anything to do with testing.  They range from just like an ESLint plugin, or a port plugin, or a snapshot implementation, or all the low-level implementations of Jest.  In Facebook, we use this hastemap package, in Instagram, for React's native packager, and and the snapshot package has also been adopted by another -- and React development libraries like storybook, and style guides.
       And then the Jest Validate Package is a tool that can help you for your own JavaScript tools to make them easier to set them up and, give meaningful error messages to your users and I'll show you a quick example of this one because I think it's pretty cool.  I think I'm sure all of you can agree with me that it's -- if you drop Jest Validate into your own projects, you can make it easier for everybody.  So in this case, if you're setting up Jest for the first time, and you have a typo in your configuration, it will yell at you and that's very easy to set up.  So packages help you to consolidate infrastructure and share best practices.  It's a good case when all the parts together, Jest, is pretty good.  But the parts, individually, they're also great.
       And by sharing best practices, the way I see it, the more we can standardized in how we write tests, the easier it will be for people to write effective tests.  And then the other effect of the separation of concerns had was it made Jest more hackable and we were able to make a great open source community around it.  For example, which is the editor integration in VS have interesting code for Jest.  And we managed to merge the generic pieces back into Jest so that other ADEs could adopt and provide a great user experience to Jest.  We managed to add two core contributes to Jest who are not working at Facebook and they're contributing to Jest on their own time.  So I'll show you an example of that.  So Rahelian Miguel joined, and I was like, I should just build this type ahead like I did earlier, right?  And it's a fairly complex feature, and one day I woke up and Rahelian was like, I found this really interesting, and I went ahead and built it.  And I came back and I said, wow, this is amazing, we have to use that.  And then a couple of days later, he just came back and said, here's another pull request, and I rewrote the entire test.  It's awesome.  Let's ship it.  And that was a great experience.  And Rahelian did a ton of great work with Jest and even presented it at React Conf.  And so the Jest project is easily contributable to everybody.  We know that there's new contributors to Jest every week that we haven't even known about before.  So that's awesome.  And the -- conferences like this one -- there's tutorials, blog posts, books even written about Jest, and then, finally, I feel like we have new conventions about simplifying testing and writing new tests and I find that really exciting.  One thing that I'm going to ask you, the JavaScript community is -- we need help with translations.  Documentation is essential to teach people how to write tests and if documentation is not written in the language that you're most familiar with, it's really hard to get started.  So if you have some time, if you speak another language, please help us translate the documentation for Jest.  We would really appreciate it.  But that's still not enough to get people to adopt Jest.  We need something more if you have an existing project.  And some people might have seen this slide before and they're catching on to what I'm trying to do here.  So I was here about two years ago, and I announced this concept of code mods to the JavaScript community, right?  It's, like, this system of how you can transform entire codebases to new APIs, right?  So there's this project called jest-codemods, and with jscodeshift, you can convert a project to Jest.  Here's a small refresher.  Say you have this test with jscodeshift, and jest-codemods, you can automatically convert this and print all of your files in a way as if you have written themselves and export them immediately in a couple of seconds and I have a short demo of this.  So I found this project.  All I did so far, I've added Jest, it has a couple hundred tests and then I just type jest-codemods.  Not codemod, codemods.  And I've looked at this before, and I hit inspect.  Codemods break down silos between frameworks.  They allow you to move from one framework to other frameworks in a couple of seconds.  And all we need to do now is run Jest, and I've tested it before, so you get a nice performance speed-up.  That is the wrong version of Jest, also.  I apologize.  We need Yarn for this.  Okay.  This is going to take a couple of seconds.  So this is super exciting.  You can just go to a new test runner.  All right.  There's only about eight tests failing out of 300.  So I feel pretty good about this.  So I just wanted to send a quick -- it is not -- there it is.
       I'll explain a bit more later.  All right.  We got this, cool.  The best part of this story that Jest code mods was entirely community driven.  The project was created by the community, iterated on by the community, and is maintained by the community.  This is awesome.  As a result, more than 100 companies have told us they've adopted Jest in the last six months alone.  Some of them are really big, some of them are really small.  So it's impossible without code mods.  If we look at metrics at Facebook, the number of tests people wrote in the last six months has grown by 35%, which is more than twice as much as it has grown ever before.
       When we improved our testing experience, people at Facebook naturally started writing more tests.  And after all this, the experience of writing tests with Jest is not painful anymore.  And I would even say that it's more than just painless.  It's now a product that gives confidence to engineers when they're building software.  And not only did we accomplish that, we also made testing fun and exciting.  And, finally, I've been mentioning Jest a few times in the last 20 minutes and I've pointed out a bunch of major features that we are going to do ship.  It's been a while since we've had a major release and we've worked really, really hard on this.  It's the biggest Jest release that we've ever made and I was gonna show and ship this to you right now.  We just need to publish it with Yarn and Lerna and this is going to be a major -- of course, it's going to be awesome.  And then I need to merge this.  I'll send another pull request right now, quick.  Just one moment.  All right.  Sweet.
       So that's two pull requests.  I think that's enough for today.
       
       [ Applause ]
       
       Thank you.  What you've seen today is that building tools is successful when you look beyond your own walls and you collaborate with the wider JavaScript community.  With Jest, which was a lesson that we learned the hard way, you know?  But the best part about working together is that the best ideas often come from people who you don't work with every day and the result is products that we can turn with a delightful experience.  Thank you very much.
>>    Thank you, Chris.  How's everyone?  Falling asleep?  Getting more coffee?  Where? save?  Well, okay.  I was thinking of an interpretive dance but I feel like not everyone wants to see that, so maybe we're going to skip that part.  All right.  We skipped the awkward part of me trying to dance, which is great for you and we have our next speaker, Matthew, who's working at BBC, and he's going to tell you all the awesome things that you can do with video and the browser.  Please give a warm, warm welcome to Matt.