Denis Radin - Applying NASA coding standards to JavaScript
>> Good morning, everyone!  How was breakfast?  Yes, the waffles and eggs were amazing. Let's start off the morning with NASA coding standards. Please give it up for Denis. [Applause] . 
DENIS:  Good morning, guys. I hope you have had a nice breakfast and that you're filled out with energy enough to make this mental shift on applying NASA coding standards to JavaScript. This talk is actually composed of two talks I have given before, so the first talk is about exploring what boundaries of JavaScript could be, and then the second talk is about why they're not there and how to get there, how to ensure more trust in JavaScript. My name is Denis Radin. You will find me on the network as an open source commander. I'm a mobile developer. Before talking about JavaScript guidelines, let's talk about the guidelines for this universe. One of the fundamental tendencies of this universe is a tendency to unification. This universe respects unification - the shape of planets, the laws of physics are constant every, will be unified in this universe. According to Wikipedia unification is to place elements in particular order built on strict systems which is comfortable to use. Increase the diversity, comfortable to use, strict system. Yes there are standardised in this universe. They very similar, a bit different, very individual but they tend to be standardised and then humanity adopted this tending to standardisation also. Every time we start something new, we start on some new field, a technology field, industry, or whatever, we start with whole variety of possible solutions. It works for politics, for economics, for art, for engineering, and, yes, today, we're going to talk about engineering first of all.  As I said, in the beginning, we do the whole lot of possible solutions whatever is the best - but only the best, most sufficient survive. You see a plan in the background. - you see a plane in the background. Can you distinguish if it is a Boeing or Airbus?  Maybe someone can?  Maybe maybe not, to be honest. This one, it's very similar. They're really only specialist can distinguish Boeing or Airbus. If you go to the plane, you can see if it is a Boeing or an Airbus, but it was not like that in the beginning, some crazy constructions. The same kind of story we see in software development. We develop software for 60 years, but such a common thing as defining a UI is not standardised yet. It's not standardised yet, so it still looks like the early ages of aviation, so let's try to compare early ages of aviation with our current state of what we recently had in a front-end, developer, and compare solutions from ten development, the solutions - okay. The early ages of aviation, I welcoming with it. I don't think it works.  -- I connect with it. I don't think it works. Can you help me with that?  I can connect to Wi-Fi. Yes, Wi-Fi's good. Should I put the show password?  You don't have the password. Oh, really ... [suggestions shouted from the audience]. No. It works!  Amazing. [Applause].  Here is where we have a problem. Is it going to work here?  No, still, okay ... . If I do a refresh. Then ... no, sorry, guys, it doesn't work. Is there another cord, maybe?  No?  No internet?  [Sighs]. So, no chance?  Maybe 4G?  Someone has good 4G?  Let's do it. Then the password is ... [Laughter]  You've seen it?  No, please!  Patrick, now you should be somewhere close to the stage. Thank you. [Applause]. That was a collaboration. Great. So, yes, as I said, 60 years of trying to make things standardised in UI development, software development industry, but we still don't have standards. It reminds me of the early ages of aviation when when we had the solutions to make early flight. Let's try to compare early ages of aviation with early ages of software development we have now. This amazing video, technologies. What kind of technology is that?  Microsoft Silverlight. Adobe Flex. It's a good try. It's completely amazing. That's the Flash. It almost did it, and it was pretty at first. My favourite. He's not shooting himself in the leg, but just Java applets!  [Laughter]. So, yes, basically, as I said, once we start something, we try all kinds of different solutions but then only the best survive and the same works for software engineering, for any kind of engineering. All planets around, a lot of physics constant everywhere and all UIs are going to be unified. What is going to be the standard for UIs?  Let's get it. We all want it, a web platform. We all believe it which is why we are here together at this conference. And it seems I'm a big - I try to have my two positions together - so, if ovation has UI was then UI innovation is going to be standardised with the UI development, so, why not to build your aircraft instrument with HTML JavaScript?  Why not. There is a motivation for that. There is a motivation in terms of unification, liability and accessibility. First of all, we live in the age of drones, unmanned drones, then access to a state of a flight mission, where HTTP, for example, is a pretty good thing to have, then unification means we have a lot of developers developing with JavaScript and web technologies, and it's not that hard to develop flight instrument, to be honest. I mean, displaying interfaces. It is good unified technology. Also, if you think about the web platform, it is amazingly reliable. The billions of users daily opens billions of pages. And they constantly contribute to a safety and a reliability of a platform. And also, once we have unified technology to general instruments, we can establish a components market for our products and some of you can develop aircraft instruments and sell them to Boeing, for example. For example, why not?  Once I saw that there is a motivation, let's try to do that, it was not hard, to be honest. There were some caveats, but then we ended up by a real, real flight on a real planet was - Flying around Amsterdam around 1,000 metres here, a real HTML thing and we will flying and relying on it. Yes, maybe it was cool, actually.  First ever flight with HTML/JavaScript instrument, but then, okay would be we did it. The considerations there to consider was of course reliability. Of course, we need, if you have problems with your instruments, fuck - less responsive instrument and it's better than can make fresh, then resources can - efficiency also to think about maybe for this you can use GPU accelerated pass or alternative rendering members of rendering on canvas. Now, you can imagine, you can take your place in an aeroplane and someone says to you, "Hey, with man, flight commander have a JavaScript-driven instrument in his cabin." You're going to fly it on a Boeing, on a JavaScript-driven Boeing. The web developer, JavaScript developer dropped fuel lines and you're going to fly with that. You're going to be scared definitely, or not?  Who will fly this plane?  Yes, it was quick. I get back. Yes. But just let's think why you're not going to fly this plane. It is basically your perception of yourself, your perception of web development, and your perception of JavaScript development. It is basically your trust in yourself, your trust in the web platform, it is your trust in guidelines in what is normal for JavaScript. Of course, it is easy to understand why it happened because the price, the price of mistake, of error, is very cheap in a JavaScript roll. Just reload the page, everything starts again, you're safe, but then the rest of the missions, when it's not like that. And that was a web platform, JavaScript language, we have more and more of such missions. And we need to rethink our guidelines and rethink what's normal for JavaScript. And change the way people perceive JavaScript and how we trust ourselves. So, we need more guidelines, probably, to change the way what's normal. Let's have a look at Jet Propulsion Laboratory which is the institution.  It is a NASA kind of branch which works on projects like Curiosity Mars Rover and the Voyager, which is amazing because it is 36 years flying in deep space without any bucks. Can JavaScript do that?  No. We have a similar problem, when I used to work for Unity Media on a set-top boxes. We had the set-top boxes, half a million lines of code, and the stability and performance were pretty high-priority, so one month without reset was pretty challenging. We tried to adopt this NASA guidelines. It is not - it is not some weird thing. It is really guidelines which GPLU and NASA use and they're published online. You can check them. Yes, let's try. Rule number 1:  no function should be longer than what can be printed on a sheet of paper. It comes from all times. You may have seen this photo. It is Margaret Hamilton with the author of Apollo mission source code, staying with the source code, basically, and it's easy to understand why they were talking about sheets of paper at that time, but now - it means higher readability compared to what you have written altogether, you can impose your functions better. Better at composibility, also. Then, yes, in if you don't do it, it is obvious. It's really obvious to adopt this rule. Rule number 2 constructs do not use go-to statements and indirect recursion. Go-to is easy to understand but what about recursion?  How can we live without recursion and why so NASA want to be?  The reason for that is that NASA relies on static analysis a lot and they want code to be predictable. They use static analysis for that. What sounds like rule number two, predictability. If you want to write reliable code, then start to write predictable code. Define code in standards, follow it. Now it is really a important part of JavaScript if you don't use aesthetic analysis, you should use aesthetic analysis to support standard. US ES link with plug-ins. Airbnb is a good place to start. There are a whole local load of plugins, but there are a lot of nice things happening to increase the quality of your code, and support the standard you established. Collect metrics because you need to track how things are going in your code base and analyse types. Right, good tools for analysing types now. Rule number 3:  do not use memory, dynamic memory allocation after initialisation. Okay, so it's really weird advice for JavaScript land because JavaScript has dynamic memory allocation by default and then memory is managed by JavaScript and garbage collection. That's a problem because we got too relaxed about that and many environment don't respect. Respect that because garbage collection might become your enemy. I will not run into details balls I have the shrinks, but then I don't think I have enough of time. I hope everybody knows why garbage collection is bad and how to - how basically to work with memory leaks and our to, or someone want to look how timeline works. No, okay. Then measure with dev tool timeline how much memory I'm going to use and then compare the state of your application, snapshots of your application to see where the memory leaks, the state of the system of your memory, and then, yes, just take care of your memory. Variables top of the scope to increase serviceability, use CS lint first on top, one place to keep Europe variables. Source them for predictability. Watch memory leaks, clean listeners and variables not used more. Use ESLint, it is very important to start with that. Switch to JavaScript aesthetic memory mode with object pooling. Some of them know there is kind of an option to have less memory allocation during the runtime by using object pulling so it looks like you set objects initially when the application starts, for example, you create 256 objects, then you have a function to get object from pool and you put it back, release object. You always use the 256 objects then it is less memory allocation. It is not static, right, but at least you try. All must have a fixed set upper bound. It also comes from NASA tend to have a good static analysis, but I don't think we should follow this rule. We would like to have recursion still and we would like to be flexible. The assertion density should average two assertions per function. Assertion is not a unit test. It is something run in runtime and it checks the state of publication matches given. So rule number 5 means sounds like test well. Right?  Minimum amount of test is super function. Analysis systems state you're in runtime generate errors in case of critical considerations. Mission coverage but be aware. 100 coverage doesn't mean you have well toasted code because coverage is a quantitative not qualitative metric. Then rule number 6:  data objects must be declared at the smallest possible level of scope. That is basically all about your table, and many of us, most of us, face this problem. There are good tools now in the JavaScript world to solve this problem, then, yes, things like Redux, unidirection flows, and so on. Anyway, it is really nice to see there are good matches between NASA needs, NASA problems and our problems, and we also have some solutions for them.  Yes, it is also good for plugins there, developed by Roman Melnick and works pretty £well. For example, you can test your reducers for pureness. Rule number 7. This rule, NASA say they break the most of them. Basically, it says rather than develop - each - you call functions then you immediately check is it the correct response from it?  Not. Then NASA often break it. I don't think we are going to use it as well. So rule number 7 we will skip. 
Rule number 8:  the use of pre-processor must be limited to the inclusion of header files or simple - says the - we have a lot of pre-processing now in JavaScript also, but actually there are two problems with that. The first problem with pre-processing, this transpiling is that you don't only the code you execute any more, the browser executes. It is pretty reliable nowadays but still you should keep in mind the coat you write is not the code you execute, and there is - coat you write is not the code you execute. There is a price for that. Comparing performance of - transpilation engines. Sometimes, it is identical. A few months ago, a year ago, it was very different. I mean, there are a lot of green fields but still some yellow stuff means two times slower, three times slower. Transpilation has a price and you should be aware of that. There is a cost for bundling and transpiling. There is a table of differences, different bundlers, and the difference sometimes is 10 or 20 per cent, so it's remarkable. You even may change your bundling system because of that, but I don't think you will do. 
Rule number 9:  the use of pointers should be restricted especially no more than one level of the references allow. Function pointers are not permitted. Okay, it is hard to use for JavaScript because the object, then we have a lot of pointers, but, yes, still can be used.  Because in two ways:  so, one of them is code change. So, if you use call change it's the level of the reference, as we say. We had a less performance because every call by the chain takes some time so it decreases performance. So, loose coupling. That is just an or architect usual patterning, not JavaScript or C. If you have a dog - a classic example - you don't say - you just say "dog run" and the dog knows how to run depends on its own state. So loose coupling and the smaller code change.  Rule number 10:  all code must be compiled from the first day of development with no compiler warnings enabled. This basically is the most important one. It is basically the way you perceive your process is the way you receive your code base, and just let's name it, keep it green. Keep it green foreign the first day of development. Perceive your project assumption series from the first day of development. I know some of you already started with a different approach. So you are already red. What do you do if you already fucked up?  Don't panic. Prioritise your models, do tests, implement standards, implement style we were talking about. It was ten rules of NASA. The tenth is the last one. Then trying adopting them and more things, more plugins been by establishing standards, by making your code base better, by improving the process, we can make this visit which currently does not allow you to fly on a JavaScript-driven aeroplane. We can make this change, and to perceive ourselves differently, to perceive ourselves like developers who produce first-class code, who produce the same kind of code people?  NASA and GPL produce, and if it goes this way, if it constantly improves our code analysis tools, our process, and our perception of web development, our trust in ourselves, one day, we're going to be there. One day, we are going to be on aeroplanes - I know some people already interest in aeroplanes using Node.js in Boeing, but they standard some models at KLM in the Netherlands, they standardise to put in a rack on the Airbus, and, it works. It is not connected to the flight system but they use it for media, but it is a long way to standardise the JS models for that. They did it. Boeing is already on Boeing and Airbus. So, yes, let's try and we, why not - also, the Netherlands company are building ships with JavaScript. If ships are there, planes are there. What stops us?  Only trust in our ourselves, only our perception of web development and our perception of JavaScript. That's it. Thank you. [Applause].  
>> Thank you, Denis for the fantastic talk. 