Steve Kinney Unconscious Bias - We're all guilty
>> Hello, everyone. Welcome back from the break. How is everyone holding up?  Excellent!  Let's talk about bringing back the 1990s. Let me introduce Steve who is going to introduce exactly that. [Cheering]. 
STEVE:  Hello. We're going to talk about three very important things as signified by this very important-looking slide:  the 1990s, JavaScript, and style sheets. As if that wasn't totally clear. My name is Steve Kinney. I have this very unique Twitter handle, where you can hear me complain about the current members of Blink 182. If you want to come visit Colorado this summer, and see Tom and see Monica, a bunch of people you saw this weekend, see them again, we will have the encore presentation in Denver on 15 and 6 June. Talking about teaching or learning or that kind of stuff, please come and find me afterwards. Right now, I'm a certain front end engineer at SendGrid. If you ever got a receipt from Uber - I work on the marketing emails client which means I take arbitrary user mark-up in CSS and then try to create a drag-and-drop editor and then try to make something that works in L2007. It is a wonderful platform. If you thought IE6 was rough, outlook said outlook, hold my beer. It uses Word's rendering engine. If you want to talk about conditional tags and table-based layouts, come and talk to me after this. I worked on a book called Electron in Action. Our story starts today in the year 1996. The best part about doing a slight check from the 1990s is you can use the animations you never thought possible and taste goes out. Let's remember what it was like in 1996. The popular cellphone at the time did not have a head phone Jack. We walked around with digital pets. We neglected the digital pets. We cloned a sheep and the Beatles. And this happened. Rachel gave us a taste yesterday of some of the wonderment that was the web in the 1990s from a very cultural standpoint. I myself was a web developer at age 12 and made a website of Mortal Combat cheap codes. I had a bunch of animated gifs for no reason. Little to no concern for accessibility. It took about three minutes to download the assets and played a music file without the user's content - like the web pages in 2017!  I did find this Doom website which is pretty much my aesthetic at the time. Just imagine everything Doom-like with the same background, divider bar, everything along those lines. So mother just - some other other websites at the time on geocities that you could find - yes, Bobby, you do!  It had a midi file which was great. I. The way you made websites was you took your styles and inlined them with style tags. You kept going as you went at every subsequent tag if the background colour needed to change. If we wanted to have a marquee with a different background colour, you could do that. You laugh at the marquee tag. This is what I write in my job now which is table-based layouts. I still live in this world, and I know it very well. This is not a retrospective for me, it is like my day to day. You laugh at the marquee magazine. It still works in Chrome today. It can be used, if that is the designer aesthetic that you're going for. The page got on a web ring. That was great. I got listed on a sub directory on Yahoo and you might say a web ring, who needs more than one mortal code cheat code website?  I was 12. Try to stay on topic and focus. Keep that in mind next time you might want to write a think piece about JavaScript fatigue!  So the hit counter hit 100, which is very impressive considering that I was paying by minute so it was time for a redesign. Going through and updating the tags can pest be described in this stock photograph. To give you a sense for those who didn't have to update a page from the 1990s, it was like migrating from one version of Angular to the next!  Luckily, there were frames so you had isolated components that you could cash with their own style.  Again, you laugh but still supported in Chrome. The things that, the - some of the style sheets today existed at the time but I was unaware of them. The first web browser, the one developed at CERN by Tim Berners-Lee - you might know him as a web developer!  - actually had support for this thing called style sheets. There wasn't a formal shared syntax but the browser itself supported this idea that you could define what all the styles should look like. In fact, the voila browser was one of the first browsers to implement this and ship it. It is very hard to find screen shots from the early 1990s, by the way. Mosaic browser took a step back and didn't allow users to use style sheets. I noticed that Mosiac renders something different than links and I wonder if I can have any control over that. To which the response was, "In fact, it has been a constant source of delight for me over the past year to tell hordes of people who want to strap themselves and control the way your document that would be trivial in every other common text processing environment. Sorry, you're screwed.". the idea of style sheets was that the browser could have some say what an-1 should look like in a paragraph. Ideally, the user could do that until someone sent a reset CSS in there. Netscape supported this, still in modern browsers like Firefox. There was a third group of people who wanted a say over their style at the time. Authors like yourself and people like me with important Mortal Combat web pages. Not to say these people could be trusted. This is a website I designed in 2004. So there is no accounting for taste when people got access to these style sheets. There were as many ten different implementations of style sheets at the time. We will talk about two of them - CSS and JavaScript style sheets. There was no logo for, and found fair to grasp the worst possible logo for CSS. They came about in Netscape 4.0. That was the only time they were seen in the wild. Let's look what these style sheets look like. Let's leave, and here we go. We have a modern web browser, and some mark-up. So there is some tasting notes here. You will notice that we have a link, a still sheet link, but it goes to this JS immediately of a CSS. That is the first clue that you might be using JavaScript style sheets. After that, we have some very non-exciting mark-up, careful readers will notice the "segum ipsum", a little bit of form along those lines. One thing that I learned along the way is that there was no document.element.get.id yet. In fact, Netscape through away the DOM after it rendered it and showed the original version there so it limited a lot what you could do at the time. Let's play around with it a second. We can see that there is nothing right now but we could theoretically write, "Document.  Tags H1." Colour is red. Cool. Let's go ahead and refresh that. And you see that there are lovely H1 turns red. Other things that we might want to do. For instance, in the notes, they said make sure that your fonts are 24 pixels so everyone can see them. Let's put that in as well. You can see we can style individual tags. So then, I know CSS, right?  I don't want to use dots for classes, how do we do that?  We had a slightly different way of doing that. We could say document - and the document was actually arbitrary, it was window, it was a global at the time. We could say classes and we could say I believe that it was called first, our first paragraph. You have to say what kind of tag that would be. You could say a P and then you could say background colour, weee!  Equals green. I don't know, why not?  We've seen my taste already. It can't hurt. Save that. This editor is from the 1990s. It is not funny!  If you wanted to get everything with a class at first, which is the only one, you could say Al-tags in this situation. Cool - all tags in this situation. JavaScript style sheets had other interesting things. They had variables. So I could say bar colour is equal to green, and I could use that as well. All right. And you can see that works as well. We had variables, all the JavaScript programming language available to us. You could even, if you really wanted to, add a little bit of uncertainty to your web page, right?  You could say, "Hey, give me a random number and round it to 0 or 1 and use in a as the background colour of the page." Sometimes it would be black and sometimes white. You could set the variables and use it altogether. You could say do you want to implement a dark mode which was very popular in like 2010. Go ahead and do that as well. And now if it was in dark mode, you got these different colours versus if that was not set to true. In fact, you could do some interesting things because you had stuff like "confirm" so you could ask the user did they want to go back to dark mode, and you could style it based on user input. If writing tags and documents every time was too verbose, we could go ahead and use everyone's friend, the "with" key word in JavaScript and get the same basic effect as well. There were some interesting things you could do as well where the page was evaluated - it's hard to tell because I don't have any dev tools and there are no events or anything like that, but here we will say, when this style sheet loads, let's measure the inner width, and, if it is less than 600, let's make the background colour red otherwise make it blue. Like the early-days media queries. Here we go. If I grab the edge of this - can he grab the edge - let's grab this corner down here. You can see we have the beginnings of responsive design in 1995 when you would have been looking at your Motorola Star Tech. There are fun things that we could have done in this land. Like the web itself wasn't ready for the sheer awesomeness that the style sheets would behold, like vendor pre-fixes. But imagine or something like "view with" and create our own extra units. We had the full power of a programming language to figure out how we style things. Cool. That done includes our live coding portion of the show. There were still things, like specificity, right?  You weren't getting away from that one. It followed the same rules that it did back - we will talk about that in a second. There was a submission to the W3C to make it part of a spec and it never came to be, so there were some things that were in the spec that didn't actually work in Netscape sparse I can tell. One interesting one was "evaluate style" and you're, "Where's the function key word?  I likely don't know. I've tried it with and without." You could use functions to evaluate based on other parts of the style sheet what another style should be. Why you would use it in this case, I don't know. But there it is. Then you're going to apply it to all sorts of different things. People were very excited about this. The big thing about JSSS is you could change the colour and font size based on user interaction. Spoiler alert:  this is something we're still chasing now. So, the - we all know how the story ends. CSS was adopted by Internet Explorer 3 and accepted as a standard to the W3C. Your options were you could in Netscape write JSSS or JavaScript style sheets, now logo, before you could only write in CSS.  People made the obvious choice and just used CSS. It turned out Netscape thought JSSS would be the be all and end all and the - it just shelled out to the JavaScript - implement style sheets ultimately came to a close like the Fresh Prince of Bel Air. They were removed - there were a lot of missed opportunity here. What if throughout the kind of today we could have used Modernizr to do feature detections and have an ultimate style sheet on the fly and have a style sheet to figure out how to move back to more supported properties?  You can imagine this is fictitious code, you can imagine a world where we had code-split CSS files or JavaScript style sheet fliers and loaded on the fly based on the user navigating or taking a given action. You could theoretically do this based on user action, right, if you had to interrupt. In my experimentation, if you put a variable on the window object, you could access in your JavaScript later on. It didn't work the other way. Again, I don't fully know why. In this fictitious perfect world, we can see a world where we can all of a sudden have interaction between JavaScript and our styles.  
          So as I said, JavaScript style sheets didn't make it, but like a bunch of ideas like really half-kept cropping up over and over and over again over the years. Sass and Less gave us functions, and variables, and conditionals. These were like a powerful way in the way we style things today. jQuery even took this idea of finding by a selector and being able to manipulate the way something looked to another level as well. CSS4 brought us variables, and even some functions like calc. These are ideas, that even though they didn't survive in the first iteration, they were ones that we looked at again and again. All of these, CSS4 aside, have some limitations. A very handsome man once drew the line between static analysis and dynamic analysis. We couldn't run a style sheet because we came up with a random number. We don't have that introspection we had potentially with the real JavaScript style sheets or my fictitious examples earlier. We do have a little bit of access with the thing called the CSS object model which you may or may not have ever heard of. It is very cool but kind of incomplete. Basically, you open up your Chrome developer tools and go to document.style sheets, you can access all the style sheets that have been loaded by the browser, look at their rules, insert and delete rules, on the fly. It is really cool but it has some limitations - one, cross-origin sheets. Two, there is no real way to traverse it. It is an example where you can navigate through, and you could iterate it is an array-like object so you could loop over it and will give you the amazing effect as we change the background colour of the body on a said interval. We could theoretically implement some of those fake ideas from the JavaScript style sheet, but it's the under-specced so not clear how it works every time on every producer so generally speaking, not our best option. We don't have the tools to work with it. All browsers come with a DOM parser that let's us manipulate. We could use post-CSS read the style tag and use the stuff at run time, but it doesn't work out so great.  
          As our craft has developed, we've taken this giant document viewer and our craft as evolved. JavaScript developers have taken on these different live techniques. It turns out an object that has its own property doesn't work out in Netscape Navigator 4. By walking this code of how were to implement stuff, we've been able to kind of move the web forward, but we mate our tools better, and eventually, we made the platform better. I think really strongly the way we've made JavaScript such an amazing platform is doing things we were not supposed to do, working around the hard parts, automating that work and eventually fixing the platform itself. As we come to this component-based approach where everything is isolated and encapsulated, we decided that it is CSS that is limiting us at this point. And there are some really good points to this, right?  All styles are in the global scope. It is tricky to figure out dependencies, sharing constants unless you're like me on Ruby on Rails in 2010 - REBs things into your templates - don't do that!  - these are big problems. Like writing over another style. You know, it is very mutable, whatever comes last wins in a lot of cases. I know that people who knew CSS really well were arguing this this pain don't seem the same thing. I would always take pause when we find ourselves with somebody who knows something more than I do doesn't see the problem in the same way. I thought a lot about this. I came from Ruby originally, and a few years ago, it was not too uncommon to see things like this. And you had to ask yourself a question:  are we falling the same trap, right?  We said JavaScript couldn't be used to build robust web applications. So, as we find ourselves saying that CSS is broken, I think that that is a trap of the way we think about these things. JavaScript obviously can be used to build applications, it has been used, even some of those posts have recanted since then, and I wonder if we need to think about that in terms of our relationship with CSS?  Because CSS does - you know, it does have its rough edges. But who amongst us does not!  This is CSS Sudden Garden with different mark-up and style sheets can transform an application in amazing ways. This is in a response to the previous quote saying like, "Hey, maybe we don't want to couple the way our applications look, we can parse everything into our components but what happens when it comes to change the font across the entire page because marketing" right?  Why why throw the baby out of the bathwater. There are some troublesome parts in CSS but also some great parts. We can't inline our styles because we have a marionette and along with a WordPress site. Right, so I think a lot about this graph. I think we've solved some of it with build tools. We have style lint in post-CSS, allowing us to build up a style sheet in imports across different files. We can make sure one style isn't stepping over another one with immutable CSS. As far as the encapsulation, we have standards we're working towards to solve these problems that don't throw out CSS in the process. I think about the static and dynamic analysis we talked about yesterday. Some of the things I like to see in the platform is improved cycle time, better inside nexus at run time, right?  When I was kind of like - one of the things that means the most to me in terms of developing the platform is the single extensible web manifesto, which some people have signed, and it is this idea that we can, the low-level APIs allowing people to build ideas, and give greater insight and access to the platform itself, right, and make a few more features than we want to see and look at those kind of paths and see what we advance the platform into being. You saw Takeda 39 up here earlier -- you saw TC39 up here and the process and ways to get involved as a developer. The task of Houdini is to expose the same low-level APIs to us. Right now, we have access to the DOM, so all of our solutions involve let's us modify the DOM. We have the partial access to the CSS access model. There's a lot we don't have access to. The idea of Houdini is to give us access to parts of the process that we didn't have access to previously. JavaScript style sheets were short-lived, but there are some ideas that are obviously carried around over the last 20 years. Right now would be we are solving problems with the best tools that we have, but I think it is exciting to look at what tools we could have, right?  Thinking about what are we doing now that we would love the browser to be able to do for us?  And figuring out, like we want the web platform to be. About an hour ago, this quote, which I loved, "The nice thing about being the last talks is you can steal everyone else's ideas" is that standards of community in involvement are not standards period. I leave you with this moral of the story:  rather than work around the limitations let's push for the web platform we want. Let's work out what we want the browser to do for us and how interacting with the web, and let's start making that happen. Thank you. [Cheering] [Applause].  
>> Thank you so much for the insightful talk into the past. We're going to get set up for the next speaker. And, in the meantime, in case you haven't visited the T-shirt table that's in the corner there in the community lounge, you can get custom graphics printed on to the T-shirts. They're super cheap, and you can get free bags if still available. Check them out and visit them. They're awesome. We're going to get set up here