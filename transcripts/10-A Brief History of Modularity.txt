"A Brief History of Modularity"
Ashley Williams

>> Hi, everyone!  Okay.  I'm feeling the excitement here.  We're in the last track.  We have three more talks to go before we start partying.  So our next speaker is Ashley.  She is from New York City.  This is the New York City track.  We have four speakers from New York.  So she works at npm, AKA Wombat Development Union.  You'll have to ask her about that later.  She loves explaining it.  So she was heavily featured in the introduction video, actually, so that was a little bit of a preview.  We're going to see the full Monty now.  So here's actually with a brief history of modularity.  Give her a round of applause.
    ASHLEY:  All right.  Here everybody.  This is good.  As you filter in, I'm going to start my talk a little strange and read to you from the namesake of this talk, which is Stephen Hawking's A Brief History of Time.  So this is from chapter one, a picture of the universe, a well known scientist, once known -- he described how the Earth orbits around the sun and how the sun, in turn, orbits around the center of a vast collection of star called a galaxy typical at the end of the lecture a little old lady got up in the back of the room and said, what you have told us is rubbish.  The world is a giant plate supported on the back of a tortoise.  And the scientist gave a reply saying:  Well, what is the tortoise standing on, said the scientist.  You're very clever, young man, very clever, old lady, but it's turtles all the way down.  Now you might be wondering that our universe is some sort of plate and there are turtles floating in space.  You might think that that's an odd idea but this talk is going to be the kind of talk that's going to ask you to look at some of the concepts that you take for granted and ask you you think they're true.  Now why on earth would something like that, with turtles in space have to do with JavaScript.  And, hopefully, by the end of this talk, you'll have figured it out.
    All right.  So, hi, my name is Ashley Williams, as was introduced.  You may know me from Twitter as @agdubs, and if you do, I'm very sorry, don't follow.  I'm terrible.  I work at this company that you would npm.  Anybody heard of npm?  And that's where I work as a services engineer.  Shout out to the fact that we've released npm 5.  Download it.  It's cool.  This talk is not about that.  But if you want to talk about that, find me.  If you're the type of person that watches slides, and sees a typo, and can't handle themselves, please submit a PR.  I'm always very happy for them.  So I always like to start my talks saying I like to think about thinking, particularly the kind of thinking that happens when people write code and the point of this talk today is to maybe get you to also think, at least about the type of thinking that you do when you write code.  So to get that thinking started, I'm going to pose you with this.  I'm not going to give you my answer quite yet but this is a PR that came into a repo for a documentation project for a programming language, and they interested remove the jQuery dependency by adding 400, and removing 200.  So this comes into play with dependency, and modularity.  How many people think that this is a really obvious thing to choose, accepted or not?  All right, good.  This talk's for you!
    All right.  So I'm one of these people who has, for a very long time been a teacher as well as an engineer and I'd like to say that teaching is nature's way of letting you know how sloppy your thinking is.  And over a long period of time of teaching people Node across the world, some people in the audience are in these photos, we've run into some fascinating questions from beginners.  Now, here's one of the more fascinating ones and this is actually one of student of Steve Kinney's asked him, how did you get permission to publish a module on npm.  True question.  Many beginners think that you have to get permission, that there's an exceptionalism of being able to publish a package.  But I hope you know that is not the case, literally anyone can publish a package on npm.  Now once you get the idea of who can publish, the next one is how do you decide what goes inside a module?  So like a proper scientist and wanting to get the correct answer, I went to Twitter as I always do, because I was like, hey, what's your primary motivation for writing, or using modular code?  Now, I got a huge number of responses.  This is a topic that a lot of people like.  But it was interesting because the responses were very diverse.  So one of the first sets of responses I got was that people believed that being able to write modular code made them more disciplined, made debugging the code easier, made it easier to test or document.
    Alternatively, some people wrote that they made their code modular for reuse so that they could do something in the future in case their code changed.  I put Bradley on his own slide in a talk about modularity, you gotta give Bradley a shout-out for all the work that he's done for ES6 modules, so if you like ES6 modules, particularly in Node, you should thank him.  So, of course, it was Twitter, so there were some shit posts, and they might have been from some of the conference organizers that you know, we'll let those be.  But the biggest thing that we got was this idea of being able to reuse things, and in particular, reuse things by separating concerns.  Now, lots of people love this term separation of concerns, to the point that a lot of people said it exactly in their responses but I thought it was awful vague that it was so specific what people were saying, so I tried to push the question a bit further and I said, okay, separation of concerns, how do you decide what the concerns are?  And this really stumped people.  People went from having ones of verbose answers to going... uh, intuition mostly?  Said this person.  This person suggested throwing darts, which is about as scientific you can get, I guess.
    Now even one of my JavaScript heroes, Ryan Haberbeek, who is here as an expert, who wrote the book I learned JavaScript from, even he had an answer that, you know what, there are a lot of practical, and ethical, and even aesthetic considerations to this question of how you separate out your code and here's the punchline, the absolute best answer of how do you split up your code is people got mad when I put it all in one file.  So you remember this from the intro that I was not here for but saw on Twitter, I guess a lot of people got mad.  But believe it or not, people do get mad in programming quite a bit and I could see how if someone put their application all in one file, there would be a bunch of people grumping about it.  But looking at the summary of these things it was it was really interesting because people didn't have an idea or how or why it was a module.  However, overwhelmingly everyone thought that it was good.  No one respond with:  Don't modularize your code.  So we're in this interesting positions where there's a lot of people who feel very interested in something but don't have a solid grasp of why.  So this made me think, okay, we have this huge batch of stuff, and maybe individually they all make sense but we don't have a coherent picture of the world, a bit like this store, which is a real store outside of Madison Square Garden in New York City.  I don't know if it capitalizes on all it promises but I would assume it does.  So this made me think, and I did this classic Ashley think that other people who might not know me, might not think a normal person would do.  They would say, oh, the way that people think about modularity is the way people think about time.  You know, people have this really intuitionistic idea that time passes but no one has any friggin' idea of how time works.  If you do think you have an idea, you should find me at the party because I'm really interested.  But yeah, this made me think, I love this book, A Brief History of Time, and it goes through and chronicles the history of how we've been thinking about the universe.  So my goal today is not necessarily to give you any answers but I do want to talk about the ways that we think about modularity, and particularly give us some pointers to get us in the right direction when we talk about splitting our code because, fundamentally, splitting our code is so important and so critical to our daily lives that it's pretty unsettling that we haven't really examined it as closely as I think we should.  So I feel like I'm in a pretty good space to talk about this because the package ecosystem, I personally think is JavaScript's picture of the universe, and working at npm, I'm pretty close to that ecosystem.  So npm, I've checked this probably a week ago.  We have 472,000 packages, which puts us about -- by an -- three times as much as the next package ecosystem.
    So packages and modularity mean a lot to JavaScript because npm is the largest module repository in the world.  Potentially, the universe.  I don't know if aliens have package managers.  But I feel like we'd be in the running, all right?  But what I want to do is ask:  Okay.  Why is this the case, right?  Why are we, like, modularize all the things!  Cut my code into pieces.  This is my JavaScript!
    
    [ Laughter ]
    
    Sorry, I had to do a pizza joke.  I had to.  It's late.  Gotta get you guys going!  Anyways.  Now lets get really serious.  This is a proper computer science talk.  So let's, Dijkstra, right, so Dijkstra is in a unique position that they have to think in computational hierarchies, the automatic computer, lol, the automatic computer, haha, the automatic computer confronts us with a radical new intellectual challenge that has no precedent in our history.  So I'm not, like, the biggest fan of computer science exceptionalism but I definitely think that he's definitely onto something here.  Modularity is the way, we as programmers, address this challenge that we need to be thinking in very, very deep conceptual hierarchies.  All right.  So we know kind of the problem that modularity is solving but what is modularity?  So, again, to the good sources, let's do a little Wikipedia.
    Modular programming is a software-design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.
    So you may or may not be getting the idea but I'm a little worried about this one aspect part of it and that seems to be the clincher of that definition, all right?  So in JavaScript we have this idea called the small-modules philosophy.  How many people here have heard of that?  How many people like it?  Interesting.
    All right.  So what are the fiercest fighters for the small-modules philosophy?  And he does it with his actions because he's probably one of the most prolific publishers on npm is cindersaurus, and he says, it's all about containing complexity.  By making small, focused modules, you can build large, complex systems without having to know every single detail of how everything works.  Our short-term memory is finite.  So this doesn't get us terribly closer to where we should separate things; but it is certainly suggesting that we have a biological constraint that's gonna require us to make small packages so that we're able to actually understand the thing that we're working on, all right?  So that's obviously begs the question:  How small is too small?
    Now this is a classic critique of packages on npm.  People love getting upset about this.  The one-line Node modules program.  People don't like these, however, they are installed constantly, continue to be published and are some of the absolute most popular packages on npm.  So you have to ask yourself for all this critique, why is it that we continue to use them?  Now I can't talk about these one-line Node modules without talking about, dun-dun-dun Left Pad.  Warning, if you make jokes about Left Pad to me, I'll get really upset, okay?  But that being said, I think Left Pad is really interesting to talk about because it brings up this idea that at which point are we leveraging modularity too much.  Because at one time, someone did this package and it's only 11 lines of code here.  Is it worth it to have a way of abstracting this code out?  Is this doing us any good?  So I think actually that Left Pad was most fascinating for me was that people started getting really aggressive and they suggested that even the existence of a Left Pad module meant that we had somehow forgotten how to program, that using this at all meant that we were terrible programmers and so I kind of need a minute here, all right?  This makes me think of this talk, which if you've seen it, or seen me online, you know I'm not a fan of.  Which is this idea that there's this real programmer out there, and if you use any sort of tools, be it a build process, or a packager, or anything that contains 11 lines of code, you're not a web developer and I just have to say, that's not cool.  Building small, reusable abstractions is the foundation of literally all computer science.  So did we forget to program when we stopped writing C, stopped writing assembly, stopped doing electrical engineering, which I can only say vaguely because I have no idea what that would be called.  I assume it has to do with soldering, I don't know.  But this idea there's no true programmer because you use tools.  It's the Node true Scotsman fallacy, but I won't go through with that.  So if you think you're not a programmer because you use tools, I'll have none of that.  What I will say is that making time for modules is a great idea because this is what I envision as the best type of application.  So substack who's also a prolific author on npm describes this applications this way:  When applications are done well, they're really the application-specific brackish res do you that cannot be abstracted away.  All the reusable components s sublimate on npm where people can use it of the commons.  And if you know me, I'm a big fan of the commons, but commons are hard and [Inaudible] and it proves that we can do the commons right.
    This is the graph of our weekly downloads.  At this point, npm is averaging 2 billion downloads a week, which means something about breaking things into tiny packages is working well, all right?  So this doesn't necessarily mean that it's without problems.  So this is an Alex Norris comment and so you can just read there:  I want things to be different.  I want things to be modular!  Oh, no.  All right?
    So this is what it comes to, this fantastic book called John Gald which is about system semantics which is about how systems work, but especially about how they fail.  And so he says a complex system that works is invariably found to have evolved from a simpler system that worked, a complex system designed from scratch never works and can never be patched up to make it work.  You have to start over with a simple system.  And, right now, in the JavaScript ecosystem, we have a complex system, and this complex system has been causing us problems.  And so from now on I'm going to talk a little bit about the problems in modularity.
    So Nolan Lawson wrote:  The more I modularized my code, the bigger it gets.  Over 400 milliseconds is being spent walking my browserified tree.  And so he wrote this really interesting article called the cost of small modules, and the subtitle is why one horse-sized JavaScript duck is faster than a hundred duck-sized JavaScript horses.  And I said, come on, this is perfect but the interesting thing he goes into this is a typical web application has ton of little modules and the reason it has a ton of little modules is because this really improves developer experience, all right?  There's lots of these tools that we take for prepare for when we push our code into production.  Now, these tools are extremely important because modularizing code helps us as developers but it doesn't come without a cost, all right?  So one of the things that he notes in his article is the fact that even just splitting our code up into closures, into different functions is actually costing us a lot of time at runtime.  So looking at stuff like webpack and Browserify, and something like roll-up closure which moves you everything up into a single closure, actually if you look at these graphs, has a significant amount of runtime improvement.  There's very little of that orange runtime when you're maintaining the modularity in your runtime code versus when you're going to use something that takes that modularity and collapses it.  And also, by the way, there's tons of new ones.  There's a new one that just came out just a few days ago.  It's pretty neat and it's doing the same thing.  It's collapsing this ability to be able to modularize our code and be able to collapse it into one thing because preserving that modularity actually hurts our users because I told them that they have to stop publishing new tools because I'll never finish this talk and I'll also never finish on time but the goal here is to say that the use of modularity has grown to such a scale that web developers are being confronted with ideas that we've never anticipated.  Oftentimes when you think about performance in web development, we think about network latency.  Obviously, we're like, how long is it going to take over the network but actually it turns out that with the number of modules that we are using across all of the devices that we have, particularly, low-power devices, low-level programming concepts are now more relevant to web developers than ever and we're a little bit not prepared to understand this.
    And so I'd like to say, I for one, welcome our new compiler transpiler overlords because we need a way to mitigate the stuff that we do to improve our developer experience and not have that cost end up on our end users.  So Rich Harris, I think, says this really great.  He says:  Yes, smaller modules are easier to write, easier to test, and easier to adhere to sember.  These are all things that make your life, as a library author easier.  As we've seen, they come at a cost for others.  So the small-modules philosophy totally benefits the library writers but it disadvantages application writers because they have to deal with all of those tiny pieces when they're putting something together, and, fundamentally, because that's extremely difficult, it turns out that that modularity actually harms end users by costing them time.  So how did we end up here?
    All right?  And I love to quote Thomas Kuhn here who says, science through models through subsequent exposure to literature without knowing, or needing to know the characteristics that have given these models the status of community paradigms.  What I'm saying is that it's been a little inconvenient for us to interrogator why we love modularity so much.  We see it happening, and the tools keep happening and this is how we use it.  This is the page of the npm SeigeBot and she's saying here, your monolith is complex, your application is complex, but to split it up to modularize it actually makes it more complex.  So we're kind of complex.  So we're kind of in a pixel here because I'm saying that modularity makes it easier but it's also making it harder.  This is some graffiti that I saw in San Francisco, my solution is probably worse than the problem so we're now in another oh-no situation.  So this is one of my favorite computer scientists, Rich Hickey, and I says most of the problems of computer software are problems of conception so I want us to be focused on the problems of day to day work.  So what I'd like to say is that when we think about programming, software development is change management.  That's why we have version control, that's why we have Sember, the hardest fact about programming is that it changes and this is actually really interesting because this really is featured briefly in A Brief History of Time by Stephen Hawking because he says:  It's an interesting reflection on the characteristic of thought that no one had suggested that the universe was expanding or contracting.  Which is to say when we tried to paint a picture of the universe, they never thought that the universe would have changed, they just assumed that it was exactly the way it was.  And I think oftentimes when we think about breaking up our code, we evaluate it in that same, static way.  So it turns out that I was, like, I did ask Twitter how do you modularize.  And I did go to Google Scholar and looked on how to module and there's an amazing paper by an author named David Parnus and the paper is called On the Criteria to be Used on Decomposing Systems into Modules and it turns out that he has an answer that nobody provided when I asked on Twitter.  This is what he said, he said:  Start with a list of difficult design decisions or design decisions that are likely to change.  Each module is then designed to hide such a decision from the others.
    So here's the trick.  The goal of modularity.  We can always talk about it as making our lives easier but the truth of the matter we should be using modularity to solve things that are hard.  So all of a sudden you might be like, I had a conception about modularity that aren't correct, how do I go about computerring.  Richard says, no one is born knowing how to write software.  I don't even know how to do it right now.  I'm still trying to figure it out.  So you might be in despair.  So this is a have famous existential philosopher, Jean Paul-Sartre, and he quotes this book, In Programming in C:  Every line of code is written without reason, maintained out of weakness, and deleted by chance.  I need some water.
    Anyways but based on this level of despair, what he suggests that we do is we suggest not only do we write code to help our programs change, but we should be not focusing on code that's easy to extend, but, rather, code that is easy to delete.  He says write code that is easy to delete, not easy to extend.  Instead of building reusable software, we should try to build disposable software.  I can't tell you that deleting code is more fun than writing code.  
    So we come back to this question of do we delete this jQuery dependency.  So what I thought was very interesting about this was there's a lot of questions to ask about this.  But in the end, using the PR, and accepting the jQuery dependency is what people thought.  And more than what people saying their feelings about jQuery, what I do think it indicated so that we're kind of seeing a return to conservativism in the way that we are thinking about using modules and packages in our programming.  For a long time, we were using modules totally uncritically.  We were doing a lot of work, including lots of them and we're seeing a lot of people go the opposite direction now and there's a lot more of this not invented here.  I'm going to bundle in my code.  And not use a package, all right?  But what I want to say is I think there's a really amazing challenge here and that instead of just rejecting the idea of using tons of modularity, we should be looking for new solutions.  Modularity is an old problem that we're dealing with but at a brand-new scale that I think is really exciting.  So I had asked recently a couple of -- a few months after the first time, why do you choose to split your code and so one of my coworkers, Chris Dickinson actually had a really awesome answer.  He said I have two answers, the first one is kind of like what I would say, like, academically, but the other one is actually how I think I really feel and what he says is:  Programming is like a maze that humans lack the language to describe completely.  With practice you start to internalize the maze.  And so that can seem pretty bad and what I want to say is internalizing and utilizing intuition isn't super terrible.  It turns out dogs know calculus which is pretty neat.  You can read about this guy and his corgis to pick up a ball.  They're actually able to calculate the most efficient route, they're made of star stuff.  So we can always use intuition to figure out how to use modularity.  So we can all be a bunch of corgis. 
     So in summary, modularize your code to make your life easier for sure but the way that you modularize, the way that you separate it out is by isolating things that are hard.  That's how you're going to make your life easier.  And in fact, modularizing is not free.  It's actually pretty expensive and the consequences could be for you for other developers and also as you are end users.  So this helps you -- too many people are are all like, I don't know what all that fancy stuff is, I don't need that.  No, they're solving problems that you already have, so you should be looking into these tools and using them.  And, finally, this is a fast-moving space right now, and there's not a lot of definitive answers and I can't help but know that on Twitter recently, there's been a lot of really nasty conversations about this, so I want to say, quit being jerks on Twitter, all right?  
    So I think this problem is far from being solved and I think getting more meet me into this conversations and critically interrogating what we think about modularity is super important.  So I'll end with this.  This is from Julia Evans who everyone got mad at when she put it in one file.  She says:  The more programming I do, the more things I run into, I don't know, Google doesn't know, my colleagues don't know, but we gotta do it anyway and when this happens, she says, right, this is why they pay a human with a brain who can investigate and learn, and these should be the problems we're most excited to solve.  Thank you so much.  This is all of the sources from the talk.  Install npm 5!
    
    [ Applause ]
    
>>  Thank you so much, Ashley.  That was really amazing.  And before you go, I took a photo of this.  So this store, in New York, that sells karate hip hop action/drama headphones and luxury.  Have you ever been in this store?
    ASHLEY:  No, I just stood outside.  I'll come back and let you know.